<% initial_team = @initial_team.to_s %>

<div
  id="salarybook"
  data-signals="{
    activeteam: '<%= initial_team %>',
    sidebarview: 'teamview',
    overlaytype: 'none',
    overlayid: '',
    ssestatus: 'idle',
    sseticks: 0,
    displaycapholds: false,
    displayexceptions: true,
    displaydraftpicks: true,
    displaydeadmoney: false
  }"
  data-on:salarybook-activeteam="if ($activeteam !== evt.detail.team) { $activeteam = evt.detail.team; @get('<%= tools_salary_book_sidebar_team_path(team: '__TEAM__', year: @salary_year) %>'.replace('__TEAM__', $activeteam)) }"
>
  <div id="flash"></div>

  <header id="commandbar">
    <div class="commandbar-inner">
      <div class="commandbar-title">Salary Book</div>

      <nav class="commandbar-nav">
        <a href="/tools/salary-book">Tool</a>
        <a href="/players/2544">Player (id fallback)</a>
      </nav>
    </div>

    <% if @teams_by_conference["Eastern"].any? || @teams_by_conference["Western"].any? %>
      <div class="commandbar-inner commandbar-inner--teams">
        <div class="team-selector-grid" role="navigation" aria-label="Teams">
          <% %w[Eastern Western].each do |conf| %>
            <div class="team-conf-block">
              <div class="team-conf-label"><%= conf %></div>
              <div class="team-conf-grid">
                <% @teams_by_conference[conf].each do |team| %>
                  <a
                    href="#teamsection-<%= team[:code] %>"
                    class="team-pill"
                    data-on:click.prevent="$activeteam = '<%= team[:code] %>'; window.__salaryBookScrollToTeam?.('<%= team[:code] %>', 'smooth'); @get('<%= tools_salary_book_sidebar_team_path(team: team[:code], year: @salary_year) %>')"
                    data-class="{ 'team-pill--active': $activeteam === '<%= team[:code] %>' }"
                    title="<%= team[:name] %>"
                  ><%= team[:code] %></a>
                <% end %>
              </div>
            </div>
          <% end %>
        </div>

        <%# Vertical divider %>
        <div class="commandbar-divider"></div>

        <%# Filter Toggles (client-only lenses) %>
        <div class="filter-toggles" role="group" aria-label="Display filters">
          <div class="filter-group">
            <div class="filter-group-label">Display</div>
            <div class="filter-group-items">
              <label class="filter-checkbox" for="filter-capholds">
                <input
                  type="checkbox"
                  id="filter-capholds"
                  data-bind="displaycapholds"
                  data-on:change="window.__salaryBookPreserveContext?.()"
                />
                <span class="filter-checkbox-label">Cap Holds</span>
              </label>
              <label class="filter-checkbox" for="filter-exceptions">
                <input
                  type="checkbox"
                  id="filter-exceptions"
                  data-bind="displayexceptions"
                  data-on:change="window.__salaryBookPreserveContext?.()"
                />
                <span class="filter-checkbox-label">Exceptions</span>
              </label>
              <label class="filter-checkbox" for="filter-draftpicks">
                <input
                  type="checkbox"
                  id="filter-draftpicks"
                  data-bind="displaydraftpicks"
                  data-on:change="window.__salaryBookPreserveContext?.()"
                />
                <span class="filter-checkbox-label">Draft Picks</span>
              </label>
              <label class="filter-checkbox" for="filter-deadmoney">
                <input
                  type="checkbox"
                  id="filter-deadmoney"
                  data-bind="displaydeadmoney"
                  data-on:change="window.__salaryBookPreserveContext?.()"
                />
                <span class="filter-checkbox-label">Dead Money</span>
              </label>
            </div>
          </div>
        </div>
      </div>
    <% end %>
  </header>

  <div id="viewport">
    <main id="maincanvas">
      <% if @boot_error %>
        <div class="placeholder">
          <div class="placeholder-title">Warehouse not available</div>
          <div class="placeholder-body">
            <p>Booted Rails, but querying <code>pcms.*</code> failed:</p>
            <pre><%= @boot_error %></pre>
          </div>
        </div>
      <% elsif @team_codes.empty? %>
        <div class="placeholder">
          <div class="placeholder-title">No teams found</div>
          <div class="placeholder-body">
            <p>No rows returned from <code>pcms.team_salary_warehouse</code> for <code><%= @salary_year %></code>.</p>
          </div>
        </div>
      <% else %>
        <% @team_codes.each do |team_code| %>
          <%= render partial: "tools/salary_book/team_section", locals: {
            team_code: team_code,
            players: (@players_by_team[team_code] || []),
            cap_holds: (@cap_holds_by_team[team_code] || []),
            exceptions: (@exceptions_by_team[team_code] || []),
            dead_money: (@dead_money_by_team[team_code] || []),
            picks: (@picks_by_team[team_code] || []),
            team_summaries: (@team_summaries[team_code] || {}),
            team_meta: (@team_meta_by_code[team_code] || {}),
            year: @salary_year,
            salary_years: @salary_years
          } %>
        <% end %>
      <% end %>
    </main>

    <aside id="rightpanel">
      <% if @initial_team %>
        <%= render partial: "tools/salary_book/sidebar_team", locals: {
          team_code: @initial_team,
          summary: @initial_team_summary,
          team_meta: @initial_team_meta,
          summaries_by_year: @initial_team_summaries_by_year,
          year: @salary_year
        } %>
      <% else %>
        <div id="rightpanel-base" class="panel">
          <header class="panel-header">
            <div class="panel-title">Right panel</div>
          </header>
          <div class="panel-body">
            <div class="panel-muted">Select a team.</div>
          </div>
        </div>
      <% end %>

      <div id="rightpanel-overlay"></div>

      <section class="panel sse-panel">
        <header class="panel-header">
          <div class="panel-title">SSE demo</div>
          <div class="panel-actions">
            <button
              type="button"
              class="panel-button"
              data-on:click="@get('<%= tools_salary_book_sse_demo_path %>', { openWhenHidden: true })"
            >Run</button>
          </div>
        </header>

        <div class="panel-body">
          <div class="panel-muted">
            status: <code data-text="$ssestatus"></code>
            ticks: <code data-text="$sseticks"></code>
          </div>

          <div id="sse-log" class="sse-log"></div>
        </div>
      </section>

      <section class="panel debug-panel">
        <header class="panel-header">
          <div class="panel-title">Signals (debug)</div>
        </header>
        <div class="panel-body">
          <pre class="signals-json" data-json-signals></pre>
        </div>
      </section>
    </aside>
  </div>
</div>

<script type="module">
  /**
   * Salary Book scroll spy (v1)
   *
   * Improvements over v0:
   * - Programmatic scroll lock: clicking a team in the command bar sets the
   *   active team immediately and locks the spy until scroll settles near
   *   the target (prevents flicker during smooth scroll).
   * - Active team aligns with the sticky header threshold (top of #maincanvas).
   * - Exposes a global function for programmatic navigation.
   * - Emits bubbling `salarybook-activeteam` CustomEvent for Datastar integration.
   */
  (() => {
    const main = document.getElementById("maincanvas");
    if (!main) return;

    // ---------------------------------------------------------------------------
    // State
    // ---------------------------------------------------------------------------
    let raf = null;
    let lastActiveTeam = null;

    // Programmatic scroll lock: when set, the spy ignores scroll events until
    // we reach (or get close to) the target position.
    let forcedActiveTeam = null;
    let forcedTargetTop = null;

    // Debounce timer for detecting scroll end
    let scrollEndTimer = null;
    const SCROLL_END_DELAY = 120; // ms

    // ---------------------------------------------------------------------------
    // Position cache (avoid layout thrashing during scroll)
    // ---------------------------------------------------------------------------
    let cachedSections = []; // Array of { code, top }

    const rebuildCache = () => {
      const sections = Array.from(main.querySelectorAll("section[data-teamcode]"));
      cachedSections = sections.map(el => ({
        code: el.dataset.teamcode,
        top: el.offsetTop
      }));
    };

    // Rebuild cache on initial load, resize, and DOM mutations
    rebuildCache();
    window.addEventListener("resize", () => requestAnimationFrame(rebuildCache), { passive: true });

    // MutationObserver for dynamically added/removed team sections
    const observer = new MutationObserver(() => requestAnimationFrame(rebuildCache));
    observer.observe(main, { childList: true, subtree: false });

    // ---------------------------------------------------------------------------
    // Scroll spy calculation
    // ---------------------------------------------------------------------------
    const calculateActiveTeam = () => {
      if (!cachedSections.length) return null;

      // Threshold: scroll position + small offset for natural feel
      // (switch a bit before the header exactly reaches sticky position)
      const scrollTop = main.scrollTop;
      const threshold = scrollTop + 2; // 2px tolerance

      // Find the last section whose top is <= threshold
      let active = cachedSections[0];
      for (const section of cachedSections) {
        if (section.top <= threshold) {
          active = section;
        } else {
          break;
        }
      }

      return active?.code ?? null;
    };

    const dispatchActiveTeam = (team) => {
      if (team && team !== lastActiveTeam) {
        lastActiveTeam = team;
        main.dispatchEvent(new CustomEvent("salarybook-activeteam", {
          detail: { team },
          bubbles: true
        }));
      }
    };

    // ---------------------------------------------------------------------------
    // Scroll handler
    // ---------------------------------------------------------------------------
    const handleScrollFrame = () => {
      raf = null;

      // If we have a forced active team (programmatic navigation in progress),
      // check if we've reached the target position.
      if (forcedActiveTeam !== null) {
        const currentTop = main.scrollTop;
        const tolerance = 3;

        // If we're close to the target, clear the lock
        if (forcedTargetTop !== null && Math.abs(currentTop - forcedTargetTop) <= tolerance) {
          forcedActiveTeam = null;
          forcedTargetTop = null;
        } else {
          // Still scrolling toward target â€” keep the forced team active
          dispatchActiveTeam(forcedActiveTeam);
          return;
        }
      }

      // Normal scroll spy
      const team = calculateActiveTeam();
      dispatchActiveTeam(team);
    };

    const handleScroll = () => {
      // Clear existing scroll-end timer
      if (scrollEndTimer) {
        clearTimeout(scrollEndTimer);
        scrollEndTimer = null;
      }

      // Schedule calculation via RAF (one per frame)
      if (!raf) {
        raf = requestAnimationFrame(handleScrollFrame);
      }

      // Detect scroll end for unlocking forced state
      scrollEndTimer = setTimeout(() => {
        scrollEndTimer = null;
        // On scroll end, clear forced state if still set
        if (forcedActiveTeam !== null) {
          forcedActiveTeam = null;
          forcedTargetTop = null;
          // Dispatch current position
          if (!raf) {
            raf = requestAnimationFrame(handleScrollFrame);
          }
        }
      }, SCROLL_END_DELAY);
    };

    main.addEventListener("scroll", handleScroll, { passive: true });

    // ---------------------------------------------------------------------------
    // Programmatic navigation API
    // ---------------------------------------------------------------------------
    /**
     * Scroll to a team section programmatically.
     * Sets activeTeam immediately to prevent flicker during smooth scroll.
     *
     * @param {string} teamCode - Team code to scroll to
     * @param {ScrollBehavior} behavior - 'smooth' or 'instant'
     */
    const scrollToTeam = (teamCode, behavior = "smooth") => {
      // Rebuild cache to ensure we have current positions
      rebuildCache();

      const section = cachedSections.find(s => s.code === teamCode);
      if (!section) return;

      // Set forced active team immediately (prevents flicker)
      forcedActiveTeam = teamCode;
      forcedTargetTop = section.top;

      // Dispatch immediately so UI updates before scroll starts
      dispatchActiveTeam(teamCode);

      // Perform the scroll
      const maxScroll = main.scrollHeight - main.clientHeight;
      main.scrollTo({
        top: Math.max(0, Math.min(section.top, maxScroll)),
        behavior
      });
    };

    // Expose globally for use in Datastar expressions
    window.__salaryBookScrollToTeam = scrollToTeam;

    // Expose rebuildCache for external callers
    window.__salaryBookRebuildCache = rebuildCache;

    /**
     * Preserve context after layout changes (e.g., filter toggles).
     *
     * When sections are shown/hidden, their offsetTop values change. This function:
     * 1. Waits a frame for Datastar to apply display changes
     * 2. Rebuilds the scroll-spy cache with new offsets
     * 3. Snaps back to the current active team with instant scroll
     *
     * This prevents the user from "jumping teams" when toggling filters.
     */
    const preserveContext = () => {
      // Wait for next frame so Datastar has applied display changes
      requestAnimationFrame(() => {
        // Rebuild cache with new section positions
        rebuildCache();

        // Find the current active team and snap back to it
        if (lastActiveTeam) {
          const section = cachedSections.find(s => s.code === lastActiveTeam);
          if (section) {
            // Use instant scroll (no animation) to preserve context seamlessly
            const maxScroll = main.scrollHeight - main.clientHeight;
            main.scrollTo({
              top: Math.max(0, Math.min(section.top, maxScroll)),
              behavior: "instant"
            });

            // Lock to this team briefly to prevent any flicker
            forcedActiveTeam = lastActiveTeam;
            forcedTargetTop = section.top;

            // Clear lock after a short delay (scroll is instant, so this is just safety)
            setTimeout(() => {
              if (forcedActiveTeam === lastActiveTeam) {
                forcedActiveTeam = null;
                forcedTargetTop = null;
              }
            }, 50);
          }
        }
      });
    };

    window.__salaryBookPreserveContext = preserveContext;

    // ---------------------------------------------------------------------------
    // Initial dispatch
    // ---------------------------------------------------------------------------
    // Run once on load (useful if URL has a hash or restored scroll position)
    requestAnimationFrame(() => {
      rebuildCache();
      const team = calculateActiveTeam();
      dispatchActiveTeam(team);
    });
  })();
</script>
