================================================================
Directory Structure
================================================================
.github/
  workflows/
    lint.yml
    test.yml
assets/
  demo.gif
bin/
  rails
  rubocop
  test
Chapter01/
  00-request-trace-location.rb
  01-request-gc-stats.rb
  02-request-trace-location-method.rb
  prelude.rb
Chapter02/
  views/
    books/
      index.html.erb
    categories/
      _category.html.erb
  00-book-active-record.rb
  01-book-data-mapper.rb
  02-posts-comments-rails-hanami.rb
  03-post-validations.rb
  04-post-draft-validator.rb
  05-post-publishing-validator.rb
  06-link-to-poro.rb
  07-link-to-active-model.rb
  08-books-controller.rb
  09-user-address.rb
  10-user-address-model.rb
  11-user-address-composed.rb
  12-active-model-vs-struct-performance.rb
  13-git-flog-churn-complexity.sh
  prelude.rb
Chapter03/
  assets/
    example.png
    skit.mp3
  00-active-job.rb
  01-active-job-sidekiq-testing.rb
  02-global-id.rb
  03-custom-serialiazers.rb
  04-active-storage.rb
  05-active-storage-custom-analyzer.rb
  06-active-storage-dummy-previewer.rb
  07-shortener-wrapper.rb
  08-shortener-adapterized.rb
  prelude.rb
Chapter04/
  assets/
    logo.svg
  views/
    posts/
      show.html.erb
  00-posts-controller-callbacks.rb
  01-posts-controller-callbackless.rb
  02-contextual-controller-callbacks.rb
  03-controller-authentication-callback-hidden-dependency.rb
  04-activerecord-callbacks.rb
  05-user-callbacks.rb
  06-post-transforming-callbacks.rb
  07-comment-utility-callbacks.rb
  08-user-events-subscriber.rb
  09-soft-deletable-concern.rb
  10-soft-deletable-module.rb
  11-user-authentication-behavior.rb
  12-user-authentication-concern.rb
  13-contactable-concern.rb
  14-contact-information-delegate-object.rb
  15-with-media-concern.rb
  16-media-value-object.rb
  17-current-attributes-posts.rb
  prelude.rb
Chapter05/
  00-githooks-controller-fat.rb
  01-githooks-controller-thin.rb
  02-githooks-controller-service-initial.rb
  03-githooks-controller-service-final.rb
  04-githooks-controller-service-cross-layer.rb
  githooks_controller_service_spec.rb
  githooks_controller_spec.rb
  prelude.rb
  rails_helper.rb
Chapter06/
  00-user-with-bookmarked-posts.rb
  01-application-query.rb
  02-scopes.rb
  03-reusable-scopes-arel.rb
  04-repositories.rb
  prelude.rb
Chapter07/
  views/
    03/
      invitations/
        new.html.erb
    feedbacks/
      new.html.erb
    invitations/
      new.html.erb
    registrations/
      new.html.erb
    users/
      _form.html.erb
      _user.html.erb
      edit.html.erb
      index.html.erb
      new.html.erb
      show.html.erb
  00-scaffold-controller.rb
  01-invitations-registrations-controllers.rb
  02-invitation-form.rb
  03-invitation-active-model-form.rb
  04-multi-model-form.rb
  05-model-less-form.rb
  06-filtering-controller.rb
  07-filtering-model-scopes.rb
  08-filter-object.rb
  09-application-record-filter.rb
  prelude.rb
  projects_controller_spec.rb
  rails_helper.rb
Chapter08/
  views/
    00/
      posts/
        _post.html.erb
        index.html.erb
    01/
      posts/
        _post.html.erb
        index.html.erb
    05/
      posts/
        _post.html.erb
        index.html.erb
    books/
      index.html.erb
    posts/
      show.html.erb
  00-model-view-methods.rb
  01-view-helpers.rb
  02-poro-presenters.rb
  03-simple-delegator-decorators.rb
  04-multi-presenter.rb
  05-keynote-presenter.rb
  06-keynote-presenter-view-helpers.rb
  07-leaking-decorator.rb
  08-render-json.rb
  09-poro-serializers.rb
  10-alba-serializers.rb
  prelude.rb
Chapter09/
  views/
    books/
      _form.html.erb
      index.html.erb
      new.html.erb
      show.html.erb
  00-controller-authorization-check.rb
  01-library-controller-authorization.rb
  02-roles-permissions.rb
  03-abac.rb
  04-poro-policy-objects.rb
  05-action-policy.rb
  06-authorization-in-views.rb
  07-search-form-authorization.rb
  08-n-plus-one-authorization.rb
  09-scoping-based-authorization.rb
  prelude.rb
Chapter10/
  views/
    user_mailer/
      welcome.html.erb
  00-mailer.rb
  01-service-notifications.rb
  02-custom-delivery-service.rb
  03-pluggable-delivery-sketch.rb
  04-active-delivery.rb
  05-noticed.rb
  06-bitfield-notifications.rb
  07-store-model-notifications.rb
  prelude.rb
  rails_helper.rb
Chapter11/
  views/
    01/
      quizzes/
        _student_result.html.erb
    02/
      quizzes/
        _student_result.html.erb
      results/
        index.html.erb
    03/
      results/
        index.html.erb
    04/
      results/
        index.html.erb
    05/
      components/
        search_box/
          _component.html.erb
        search_box.rb
      results/
        index.html.erb
    06/
      components/
        search_box/
          component.html.erb
          component.rb
          component.yml
        search_box.rb
    07/
      components/
        flash/
          banner/
            component.html.erb
            component.rb
          component.html.erb
          component.rb
        pure_flash/
          _component.html.erb
          component.rb
        _flash.html.erb
    courses/
      _side_info.html.erb
    quizzes/
      _student_result.html.erb
    results/
      index.html.erb
  00-partial-locals.rb
  01-partial-instance-variables.rb
  02-partial-strict-locals.rb
  03-search-box-partial.rb
  04-search-box-helper.rb
  05-plain-view-components.rb
  06-view-component.rb
  prelude.rb
Chapter12/
  config/
    00/
      layerize.yml
    layerize.yml
  lib/
    rubocop/
      lint_rails_env.rb
  .rubocop.yml
  00-multi-source-configuration.rb
  01-multi-source-yaml.rb
  02-rails-application-config.rb
  03-rubocop-lint-rails-env.rb
  04-anyway-config-basic.rb
  05-anyway-config-advanced.rb
  prelude.rb
Chapter13/
  assets/
    me.png
  00-puts-logging.rb
  01-rails-logger.rb
  02-tagged-logger.rb
  03-rails-error.rb
  04-instrumentation.rb
  05-active-storage-custom-proxy.rb
  prelude.rb
gemfiles/
  rubocop.gemfile
  rubocop.gemfile.lock
lib/
  app/
    views/
      layouts/
        application.html.erb
      welcome/
        index.html.erb
  config/
    credentials.yml.enc
    master.key
    puma.rb
  public/
    favicon.ico
  app.rb
  application.rb
  boot.rb
  config.ru
  environment.rb
  helpers.rb
.gitignore
.rubocop.yml
Answers to Questions.docx
LICENSE
Rakefile
README.md
run.rb
Solutions to Exercises.docx

================================================================
Files
================================================================

================
File: .github/workflows/lint.yml
================
name: Linters
on:
  push:
    branches:
    - main
  pull_request:
jobs:
  rubocop:
    runs-on: ubuntu-latest
    env:
      # Some gems (sqlite3 in particular) do not provide
      # prebuilt binaries for Ruby 3.2 yet
      BUNDLE_FORCE_RUBY_PLATFORM: "1"
    steps:
    - uses: actions/checkout@v2
    - uses: ruby/setup-ruby@v1
      with:
        ruby-version: 3.2
        bundler-cache: true
    - name: Lint Ruby code with RuboCop
      run: |
        bin/rubocop

================
File: .github/workflows/test.yml
================
name: Tests
on:
  push:
    branches:
    - main
  pull_request:
jobs:
  test:
    runs-on: ubuntu-latest
    env:
      # Some gems (sqlite3 in particular) do not provide
      # prebuilt binaries for Ruby 3.2 yet
      BUNDLE_FORCE_RUBY_PLATFORM: "1"
    steps:
    - uses: actions/checkout@v2
    - uses: ruby/setup-ruby@v1
      with:
        ruby-version: 3.2
    - run: gem update --system
    - name: Warmup gems
      run: |
        ruby Chapter01/00-request-trace-location.rb || true
    - name: Test examples when using pure Ruby
      run: |
        bin/test
    - name: Test examples with using runner
      run: |
        bin/test --runner

================
File: bin/rails
================
#!/usr/bin/env ruby

APP_PATH = File.expand_path("../lib/application", __dir__)

PROJECT_PATH =
  if ENV["CHAPTER"]
    chapter_dir = "Chapter#{ENV["CHAPTER"].rjust(2, "0")}"
    File.expand_path(File.join(__dir__, "..", chapter_dir, "prelude.rb"))
  else
    File.expand_path(File.join(__dir__, "..", "lib/boot"))
  end

require_relative PROJECT_PATH

Dir.chdir(File.dirname(PROJECT_PATH))

require "rails/commands"

================
File: bin/rubocop
================
#!/bin/bash

cd $(dirname $0)/..

export BUNDLE_GEMFILE=./gemfiles/rubocop.gemfile
bundle check > /dev/null || bundle install

bundle exec rubocop $@

================
File: bin/test
================
#!/usr/bin/env ruby

require "open3"
require "optparse"

mode = :ruby

OptionParser.new do |opts|
  opts.banner = "Usage: bin/test [options] [pattern]"

  opts.on("--runner", "Run examples via custom runner") do |v|
    mode = :runner
  end
end.parse!

Dir.chdir(File.join(__dir__, ".."))

failed = false

pattern = /Chapter\d{2}\/\d{2}-/

target = (ARGV.size > 0) ? ARGV[0] : "**/*.rb"

executor = (mode == :runner) ? "ruby run.rb" : "ruby"

Dir.glob(target) do |file|
  next unless file.match?(pattern)

  $stdout.print "#{executor} #{file}: "

  out, err, status = Open3.capture3("#{executor} #{file}")
  if status.success?
    $stdout.puts " âœ…"
    $stdout.puts "Errors:\n#{err.lines.take(5).join("\n")}" unless err.empty?
    next
  end

  failed = true
  $stdout.puts " ðŸ’¥ #{err.lines.take(5).join("\n")}"
  break
end

exit(1) if failed

================
File: Chapter01/00-request-trace-location.rb
================
require_relative "./prelude"
request = Rack::MockRequest.env_for("http://localhost:3000")
TraceLocation.trace(format: :log) do
  Rails.application.call(request)
end

================
File: Chapter01/01-request-gc-stats.rb
================
require_relative "./prelude"
request = Rack::MockRequest.env_for("http://localhost:3000")
was_alloc = GC.stat[:total_allocated_objects]
Rails.application.call(request)
new_alloc = GC.stat[:total_allocated_objects]
puts "Total allocations: #{new_alloc - was_alloc}"

================
File: Chapter01/02-request-trace-location-method.rb
================
require_relative "./prelude"
request = Rack::MockRequest.env_for("http://localhost:3000")
TraceLocation.trace(format: :log, methods: [:call]) do
  Rails.application.call(request)
end

================
File: Chapter01/prelude.rb
================
# frozen_string_literal: true
require_relative "../lib/helpers"
using ChapterHelpers
# Add gems
gems do
  gem "trace_location", "~> 0.12.2"
end
require_relative "../lib/boot"
# Configure output folder for trace_location
require "trace_location"
TraceLocation.configure do |config|
  config.dest_dir = File.join(__dir__, "../log")
end

================
File: Chapter02/views/books/index.html.erb
================
<%= render @categories %>

================
File: Chapter02/views/categories/_category.html.erb
================
<li>
  <%= link_to category.category, category %>
</li>

================
File: Chapter02/00-book-active-record.rb
================
require_relative "./prelude"
class Book < ApplicationRecord
end
# Inserting data into the database
Book.create!(title: "The Ruby on Rails book")
# Retrieving data via model finder methods
book = Book.find_by(title: "The Ruby on Rails book")
# Modifying data
book.update!(category: "programming")
# Deleting data
book.destroy!

================
File: Chapter02/01-book-data-mapper.rb
================
require_relative "./prelude"
class Book < Struct.new(:title, :category)
end
# BookRepository is our data mapper implementation
id = BookRepository.insert(title: "Rails and ORM", category: "programming")
book = BookRepository.find(id)
book.title

================
File: Chapter02/02-posts-comments-rails-hanami.rb
================
require_relative "./prelude"
# Active Record models
class User < ApplicationRecord
  has_many :posts, -> { order(id: :desc) }
end
class Post < ApplicationRecord
  has_many :comments, -> { order(id: :desc) }
end
class Comment < ApplicationRecord
end
# Populate demo data
user = User.create!(name: "Vova")
post_rails = user.posts.create!(title: "Rails 7.0 released!")
post_hanami = user.posts.create!(title: "Hanami 2.0 is out!")
Comment.insert_all([
  {body: "Still rocks", user_id: user.id, post_id: post_rails.id},
  {body: "All my life I've been waiting for something", user_id: user.id, post_id: post_hanami.id}
]) # :ignore:output
# Show the top-3 latest comments for the latest userâ€™s post
user.posts.first.comments.limit(3)
# Hanami repositiries
class PostRepository < Hanami::Repository
  associations do
    has_many :comments
  end
  def latest_for_user(user_id)
    posts.where(user_id:).order { id.desc }.limit(1).one
  end
end
class CommentRepository < Hanami::Repository
  def latest_for_post(post_id, count:)
    comments.where(post_id:)
      .order { id.desc }
      .limit(count).to_a
  end
end
# Fetching the user's latest post first
latest_post = PostRepository.new.latest_for_user(user.id)
# Then, fetching comments
latest_comments = CommentRepository.new.latest_for_post(latest_post.id, count: 3)

================
File: Chapter02/03-post-validations.rb
================
require_relative "./prelude"
class Post < ApplicationRecord
  validate :prevent_drafting_published,
    if: -> { published? && will_save_change_to_draft? }
  validates :title, presence: true
  def prevent_drafting_published
    errors.add(:base, "Switching back to draft is not allowed for published posts")
  end
end
post = Post.create!(title: "The Rails 4 Way", published: true)
post.update(draft: true)
puts post.errors.full_messages

================
File: Chapter02/04-post-draft-validator.rb
================
require_relative "./prelude"
# We need to initialize class first to
# use it as a namespace for validator
class Post < ApplicationRecord # :ignore:
end
class Post::DraftValidator < ActiveModel::Validator
  def validate(post)
    return unless post.published?
    return unless post.will_save_change_to_draft?
    post.errors.add(:base, "Switching back to draft is not allowed for published posts")
  end
end
class Post < ApplicationRecord
  validates_with DraftValidator
end
post = Post.create!(title: "The Rails 5 Way", published: true)
post.update(draft: true)
puts post.errors.full_messages

================
File: Chapter02/05-post-publishing-validator.rb
================
require_relative "./prelude"
# We need to initialize class first to
# use it as a namespace for validator
class Post < ApplicationRecord # :ignore:
end
class Post::PublishingValidator < ActiveModel::Validator
  def validate(post)
    return unless post.published?
    validate_publish_date(post)
    validate_author(post)
    # â€¦ more validations related to post publishing
  end
  def validate_publish_date(post)
    unless post.publish_date.present?
      return post.errors.add(:publish_date, :blank)
    end
    # Assuming we only publish posts on Tuesdays
    if post.publish_date.wday != 1
      post.errors.add(:publish_date, :not_tuesday)
    end
  end
  def validate_author(post)
    post.errors.add(:author, :blank) unless post.author
  end
end
class Post < ApplicationRecord
  validates_with PublishingValidator, on: :publish
  enum :status, {draft: "draft", published: "published"}
  def publish
    self.status = :published
    save!(context: :publish)
  end
end
post = Post.create!(title: "The Rails 5 Way")
# Post without author and publish date
begin
  post.publish
rescue ActiveRecord::RecordInvalid => e
  puts "#{e.class}: #{e.message}"
end
post.author = "Vova"
# Published on Tue
post.publish_date = Date.new(2022, 12, 13)
begin
  post.publish
rescue ActiveRecord::RecordInvalid => e
  puts "#{e.class}: #{e.message}"
end

================
File: Chapter02/06-link-to-poro.rb
================
require_relative "./prelude"
# #content_tag stub
def content_tag(tag, text, attrs = {})
  "<#{tag} #{attrs.map { |k, v| "#{k}=\"#{v}\"" }.join(" ")}>#{text}</#{tag}>"
end
def link_to(name, record)
  parts = [""]
  if record.persisted?
    parts << record.model_name.singular_route_key
    parts << record.to_param
  else
    parts << record.model_name.route_key
  end
  content_tag("a", name, {href: parts.join("/")})
end
class Book
  attr_reader :id
  def initialize(id) = @id = id
  def persisted? = true
  def to_param = id.to_s
  def model_name
    ActiveModel::Name.new(self.class)
  end
end
puts link_to("Object", Book.new(2023))

================
File: Chapter02/07-link-to-active-model.rb
================
require_relative "./prelude"
# #content_tag stub
def content_tag(tag, text, attrs = {})
  "<#{tag} #{attrs.map { |k, v| "#{k}=\"#{v}\"" }.join(" ")}>#{text}</#{tag}>"
end
def link_to(name, record)
  parts = [""]
  if record.persisted?
    parts << record.model_name.singular_route_key
    parts << record.to_param
  else
    parts << record.model_name.route_key
  end
  content_tag("a", name, {href: parts.join("/")})
end
class Book
  include ActiveModel::API
  include ActiveModel::Attributes
  attribute :id
  def persisted? = true
end
puts link_to("Object", Book.new(id: 2023))
class BookTest < ActiveSupport::TestCase
  include ActiveModel::Lint::Tests
  def setup = @model = Book.new
end
Minitest.run

================
File: Chapter02/08-books-controller.rb
================
require_relative "./prelude"
using ChapterHelpers
class Category
  include ActiveModel::API
  include ActiveModel::Attributes
  attribute :category
  ALL = %w[ruby other].freeze
  def self.all = ALL.map { new(category: _1) }
  alias_method :id, :category
  def persisted? = true
  def books = Book.where(category:)
end
class BooksController < ApplicationController
  def index
    @categories = Category.all
  end
end
response = get "/books"
puts response.body

================
File: Chapter02/09-user-address.rb
================
require_relative "./prelude"
class User < ApplicationRecord
  store :address, coder: JSON
end
user = User.create!(address: {country: "USA", city: "Bronx", street: "231st", zip: 10463})
user.address

================
File: Chapter02/10-user-address-model.rb
================
require_relative "./prelude"
class User < ApplicationRecord
  store :address, coder: JSON
  def address = @address ||= Address.new(super)
end
class User::Address
  include ActiveModel::API
  include ActiveModel::Attributes
  attribute :country
  attribute :city
  attribute :street
  attribute :zip
end
user = User.create!(address: {country: "USA", city: "Bronx", street: "231st", zip: 10463})
user.address
# Adding validations to the address model
class User::Address
  validates :country, :zip, presence: true
end
class User < ApplicationRecord
  validate do |record|
    next if address.valid?
    record.errors.add(:address, "is invalid")
  end
end
user = User.create(address: {})
user.valid?
user.errors.full_messages

================
File: Chapter02/11-user-address-composed.rb
================
require_relative "./prelude"
class User < ApplicationRecord
  composed_of :address,
    class_name: "User::Address",
    mapping: [%w[address_country], %w[address_city], %w[address_street], %w[address_zip]],
    constructor: proc { |country, city, street, zip|
      Address.new({country:, city:, street:, zip:})
    }
end
class User::Address
  include ActiveModel::API
  include ActiveModel::Attributes
  attribute :country
  attribute :city
  attribute :street
  attribute :zip
end
user = User.create!(address_country: "UK", address_city: "Birmingham", address_street: "Livery st", address_zip: "B32PB")
user.address.zip

================
File: Chapter02/12-active-model-vs-struct-performance.rb
================
require_relative "./prelude"
class ActiveUser
  include ActiveModel::API
  attr_accessor :a, :b, :c, :d, :e
end
class ActiveAttributesUser
  include ActiveModel::API
  include ActiveModel::Attributes
  %i[a b c d e].each { attribute _1 }
end
StructUser = Struct.new(:a, :b, :c, :d, :e, keyword_init: true)
Benchmark.ips do |x|
  x.report("struct") { StructUser.new(a: 1, b: 2, c: 3, d: 4, e: 5) }
  x.report("active model api") { ActiveUser.new(a: 1, b: 2, c: 3, d: 4, e: 5) }
  x.report("w/attributes") { ActiveAttributesUser.new(a: 1, b: 2, c: 3, d: 4, e: 5) }
  x.compare!
end
Benchmark.memory do |x|
  x.report("struct") { StructUser.new(a: 1, b: 2, c: 3, d: 4, e: 5) }
  x.report("active model api") { ActiveUser.new(a: 1, b: 2, c: 3, d: 4, e: 5) }
  x.report("w/attributes") { ActiveAttributesUser.new(a: 1, b: 2, c: 3, d: 4, e: 5) }
  x.compare!
end

================
File: Chapter02/13-git-flog-churn-complexity.sh
================
# See the number of commits where a particular files has been modified
git log --format=oneline -- app/models/user.rb | wc -l
# Top-10 files according to churn factor
find app/models -name "*.rb" | while read file; do echo $file `git log --format=oneline -- $file | wc -l`; done | sort -k 2 -nr | head
# Flog example usage (https://github.com/seattlerb/flog)
flog -s app/models/user.rb

================
File: Chapter02/prelude.rb
================
# frozen_string_literal: true
require_relative "../lib/helpers"
using ChapterHelpers
# EXAMPLE: 00-book-active-record.rb, 01-book-data-mapper.rb
schema do
  create_table :books, force: true do |t|
    t.string :title, null: false
    t.string :category, null: true
    t.timestamps null: true
  end
end
# EXAMPLE: 02-posts-comments-rails-rom.rb, 03-post-validations.rb
# Schema definition for users, posts and comments.
schema do
  create_table :users, force: true do |t|
    t.string :name, null: true
    t.text :address, null: true
    t.string :address_country, null: true
    t.string :address_city, null: true
    t.text :address_street, null: true
    t.string :address_zip, null: true
  end
  create_table :posts, force: true do |t|
    t.string :title, null: false
    t.boolean :published, null: false, default: false
    t.boolean :draft, null: false, default: false
    t.date :publish_date, null: true
    t.string :status, null: false, default: "draft"
    t.string :author, null: true
    t.belongs_to :user
  end
  create_table :comments, force: true do |t|
    t.string :body, null: false
    t.belongs_to :user
    t.belongs_to :post
  end
end
# Add Rom-rb
gems do
  gem "rom", "~> 5.3.0", require: false
  gem "rom-sql", "~> 3.6.1", require: false
end
# EXAMPLE: 08-books-controller.rb
routes do
  resources :books, only: [:index]
  resources :categories, only: [:index, :show]
end
# EXAMPLE: 12-active-model-vs-struct-performance.rb
gems do
  gem "benchmark-ips", "2.10.0"
  gem "benchmark-memory", "0.2.0"
end
require_relative "../lib/boot"
# Enable logging to see queries
ActiveRecord::Base.logger = ActiveSupport::Logger.new($stdout)
# Fix ROM vs Rails 7.1 incompatibility: https://github.com/rom-rb/rom/issues/684
on_const_load("ROM::SQL::Schema::Inferrer") do |mod|
  mod.__define_with__
end
require "rom"
require "rom-sql"
# Mimic Hanami Model. It doesn't work with Ruby 3.2 and no longer supported.
# Based on https://github.com/hanami/model/blob/main/lib/hanami/repository.rb
module Hanami
  class Repository
    def self.config = @config ||= ROM::Configuration.new(:sql, ENV.fetch("DATABASE_URL").sub("sqlite3", "sqlite"))
    def self.container = @container ||= ROM.container(config)
    def self.inherited(base)
      base.alias_method base.relation_name, :relation
      fiber = Fiber.new do
        relation_name = base.relation_name
        a = base.instance_variable_get(:@associations)
        klass = Class.new(ROM::Relation[:sql]) do
          schema(relation_name, infer: true) do
            associations(&a) if a
          end
          auto_struct(true)
        end
        Repository.config.register_relation(klass)
      end
      trace = TracePoint.new(:end) do |event|
        next unless event.self == base
        fiber.resume
      end.enable
    end
    def self.associations(&block) = @associations = block
    def self.relation_name = name.sub(/Repository$/, "").underscore.pluralize.to_sym
    def initialize
      @relation = Repository.container.relations[self.class.relation_name]
    end
    private
    attr_reader :relation
  end
end
# EXAMPLE: 01-book-data-mapper.rb
#
# Simple repository implementation.
DB = SQLite3::Database.new(ENV["DATABASE_URL"].sub(/^sqlite3:/, ""))
class BookRepository
  def self.insert(title:, category: nil)
    rows = DB.execute <<~SQL
      insert into books (title, category)
      values ('#{title}', #{category ? "'#{category}'" : "NULL"})
      returning id
    SQL
    rows.first.first
  end
  def self.find(id)
    rows = DB.execute <<~SQL
      select title, category
      from books
      where id = #{id}
    SQL
    row = rows.first
    return unless row
    Book.new(*row)
  end
end
# EXAMPLE: 05-post-publishing-validator.rb
#
# Add translations for validations
I18n.backend.store_translations(:en,
  activerecord: {
    errors: {
      models: {
        post: {
          attributes: {
            publish_date: {
              not_tuesday: "Should not be on Tuesday"
            }
          }
        }
      }
    }
  })

================
File: Chapter03/00-active-job.rb
================
require_relative "./prelude"
class TrackAnalyticsJob < ApplicationJob
  queue_as :low_priority
  retry_on Analytics::APIError
  discard_on Analytics::UserNotFound
  def perform(user, event)
    Analytics::Tracker.push_event(
      {user: {name: user.name, id: user.id}, event:}
    )
  end
end
user = User.find(1)
TrackAnalyticsJob.perform_later(user, "signed_in")
class NoOpAdapter
  def enqueue(*) = nil
  def enqueue_at(*) = nil
end
ActiveJob::Base.queue_adapter = NoOpAdapter.new
TrackAnalyticsJob.perform_later(user, "signed_out")

================
File: Chapter03/01-active-job-sidekiq-testing.rb
================
require_relative "./prelude"
class TrackAnalyticsJob < ApplicationJob
  queue_as :low_priority
  def perform(user, event)
    Analytics::Tracker.push_event(
      {user: {name: user.name, id: user.id}, event:}
    )
  end
end
class TrackAnalyticsWorker
  include Sidekiq::Worker
  def perform(user_id, event)
    user = User.find(user_id)
    Analytics::Tracker.push_event(
      {user: {name: user.name, id: user.id}, event:}
    )
  end
end
user = User.find(1)
TrackAnalyticsWorker.perform_async(user.id, "signed_in")
class User
  def track_event(event)
    TrackAnalyticsJob.perform_later(self, event)
  end
end
class UserTest < ActiveSupport::TestCase
  include ActiveJob::TestHelper
  test "analytics job scheduling" do
    @user = User.create!(name: "Vova")
    assert_enqueued_with(
      job: TrackAnalyticsJob,
      args: [@user, "signed_in"]
    ) do
      @user.track_event("signed_in")
    end
  end
  test "analytics active job" do
    event_checker = lambda do |event|
      assert(event => {user: {name: "Vova"}, event: "test"})
    end
    user = User.new(name: "Vova")
    Analytics::Tracker.stub :push_event, event_checker do
      TrackAnalyticsJob.perform_now(user, "test")
    end
  end
  test "analytics Sidekiq worker" do
    event_checker = lambda do |event|
      assert(event => {user: {name: "Vova"}, event: "test"})
    end
    user = User.create!(name: "Vova") # !!!
    Analytics::Tracker.stub :push_event, event_checker do
      TrackAnalyticsWorker.new.perform(user.id, "test")
    end
  end
end
Minitest.run

================
File: Chapter03/02-global-id.rb
================
require_relative "./prelude"
user = User.find(1)
user.to_global_id
# Custom global ID locator
GlobalID::Locator.use :pogo do |gid|
  gid.model_name.constantize.new(**gid.params)
end
# Global identifieable struct
class Category < Struct.new(:name, keyword_init: true)
  include GlobalID::Identification
  alias_method :id, :name
  def to_global_id(options = {})
    super({name:}.merge!(options).merge!(app: "pogo"))
  end
end
original = Category.new(name: "ruby")
located = GlobalID::Locator.locate(original.to_global_id)
located == original

================
File: Chapter03/03-custom-serialiazers.rb
================
require_relative "./prelude"
class Category < Struct.new(:name, keyword_init: true)
end
class CategoryJob < ApplicationJob
  def perform(category)
    puts "Category job: #{category.name}"
  end
end
category = Category.new(name: :rails)
# Without custom serializer, enqueing fails
begin
  CategoryJob.perform_later(category)
rescue ActiveJob::SerializationError => err
  puts "#{err.class}: #{err.message}"
end
# Custom Active Job serializer
module ActiveJob::Serializers
  class CategorySerializer < ObjectSerializer
    def serialize(cat) = super("name" => cat.name)
    def deserialize(h) = Category.new(name: h["name"])
    private def klass = Category
  end
end
ActiveJob::Serializers.add_serializers ActiveJob::Serializers::CategorySerializer
CategoryJob.perform_later(category)

================
File: Chapter03/04-active-storage.rb
================
require_relative "./prelude"
using ChapterHelpers
class Post < ApplicationRecord
  has_one_attached :image
end
# Now you can create a post with an image
image = File.open(File.join(__dir__, "assets/example.png"))
post = Post.create!(title: "Test")
post.image.attach(io: image, filename: "example.png")
binding.render <<~ERB
  <%= image_tag post.image.variant(resize: "400x300") %>
ERB

================
File: Chapter03/05-active-storage-custom-analyzer.rb
================
require_relative "./prelude"
require "id3tag"
# Custom audio analyzer adding track title and artist from ID3 MP3 tags.
class CustomAudioAnalyzer < ActiveStorage::Analyzer::AudioAnalyzer
  def metadata
    super.merge(id3_data)
  end
  private def id3_data
    tag =
      download_blob_to_tempfile do |file|
        ID3Tag.read(File.open(file.path))
      end
    {title: tag.title, artist: tag.artist}
  end
end
# Register the analyzer.
# NOTE: You should do this in the configuration:
#
#   config.active_storage.analyzers.unshift CustomAudioAnalyzer
ActiveStorage.analyzers.unshift CustomAudioAnalyzer
# Declare a model having audio attachments
class Post < ApplicationRecord
  has_one_attached :audio
end
track = File.open(File.join(__dir__, "assets/skit.mp3"))
post = Post.create!(title: "GGM")
post.audio.attach(io: track, filename: "skit.mp3")
post.audio.analyze
post.audio.analyzed?
puts post.audio.metadata.slice(:artist, :title)

================
File: Chapter03/06-active-storage-dummy-previewer.rb
================
require_relative "./prelude"
class DummyVideoPreviewer < ActiveStorage::Previewer
  def self.accept?(...) = true
  def preview(**options)
    output = File.open(File.join(__dir__, "assets", "example.png"))
    yield io: output, filename: "#{blob.filename.base}.png", content_type: "image/png", metadata: {"dummy" => true}, **options
  end
end
# Configure Active Storage previewers.
# NOTE: you should do this in configuration files (e.g., config/environments/test.rb)
#
#   config.active_storage.previewers = [DummyVideoPreviewer]
ActiveStorage.previewers = [DummyVideoPreviewer]
class Post < ApplicationRecord
  has_one_attached :video
end
video = File.open(File.join(__dir__, "../assets/demo.gif"))
post = Post.create!(title: "Demo")
post.video.attach(io: video, filename: "demo.gif")
# Generate the preview source file (not transformed)
preview = post.video.preview(resize_to_limit: [100, 100]).processed
puts preview.image.metadata

================
File: Chapter03/07-shortener-wrapper.rb
================
require_relative "./prelude"
# Phase 0: Configure an API client globally and use the third-party API everywhere
Rails.application.config.bitly_client = Bitly::API::Client.new(
  token: Rails.credentials.bitly_api_token
)
url = "https://rubyonrails.org"
short_url = Rails.application.config
  .bitly_client.shorten(long_url: url).link
# Phase 1: Introduce a Shortener domain concept
# and create a simple wrapper over Bitly API Client
class Shortener
  class << self
    delegate :shorten, to: :instance
    def instance = @instance ||= new
  end
  def initialize(token: Rails.credentials.bitly_api_token)
    @client = Bitly::API::Client.new(token:)
  end
  def shorten(long_url)
    @client.shorten(long_url:).link
  end
end
Shortener.shorten("https://rubyonrails.org")
def some_method_using_shortener
  "Short url for: #{Shortener.shorten("https://example.com")}"
end
# With a wrapper object, integration tests do not need to
# know about the particular implementation (API client)
class ShortenerTest < ActiveSupport::TestCase
  test "with shortener" do
    Shortener.stub :shorten, "http://exml.test" do
      result = some_method_using_shortener
      assert result.include?("http://exml.test")
    end
  end
end
Minitest.run

================
File: Chapter03/08-shortener-adapterized.rb
================
require_relative "./prelude"
# Shortener with adapters
class Shortener
  class << self
    attr_writer :backend
    delegate :shorten, to: :backend
    def backend
      @backend ||= BitlyBackend.new
    end
  end
  class BitlyBackend
    def initialize(token: Rails.credentials.bitly_api_token)
      @client = Bitly::API::Client.new(token:)
    end
    def shorten(long_url)
      @client.shorten(long_url:).link
    end
  end
  class NoOpBackend
    def shorten(url) = url
  end
end
Shortener.shorten("https://rubyonrails.org")
# Switch adapter to no-op (returning the long url)
Shortener.backend = Shortener::NoOpBackend.new
Shortener.shorten("https://rubyonrails.org")

================
File: Chapter03/prelude.rb
================
# frozen_string_literal: true
require_relative "../lib/helpers"
using ChapterHelpers
gems do
  # For Active Job and pure Sidekiq comparison
  gem "sidekiq", "6.0.1"
  # For custom Active Storage analyzer
  gem "id3tag", "0.14.0"
  # For custom wrapper/adaper example
  gem "bitly", "3.0.0"
  # To stub Bitly HTTP requests
  gem "webmock", "3.18.0"
end
schema do
  create_table :users, force: true do |t|
    t.string :name, null: true
  end
  create_table :posts, force: true do |t|
    t.string :title, null: true
  end
end
require_relative "../lib/boot"
# Set this global var to disable Sidekiq warning message
$TESTING = true # rubocop:disable Style/GlobalVars
require "sidekiq/testing"
Sidekiq::Testing.inline!
# Use inline adapter for Active Job as well
ActiveJob::Base.queue_adapter = :inline
# To use #stub in tests
require "minitest/mock"
class User < ApplicationRecord
end
User.create!(name: "Vova")
module Analytics
  class Error < StandardError
  end
  class APIError < Error
  end
  class UserNotFound < Error
  end
  class Tracker
    def self.push_event(payload)
      event = payload.fetch(:event)
      user = payload.fetch(:user)
      puts "[ANALYTICS] #{event}: #{user[:name]} (#{user[:id]})"
    end
  end
end
# Extend GlobalID to show human-readable representation
# in #inspect
class GlobalID
  alias_method :inspect, :to_s
end
# Stub Rails credentials
module Rails
  def self.credentials
    Object.new.tap do
      _1.define_singleton_method(:bitly_api_token) { ENV.fetch("BITLY_API_TOKEN", "bitlys") }
    end
  end
end
# Intercept Bit.ly requests if no real token is provided
if ENV["BITLY_API_TOKEN"].blank?
  require "webmock"
  WebMock.enable!
  mocked_response = {
    "created_at" => "2022-12-10T23:51:47+0000",
    "link" => "https://bit.ly/3Use6uj",
    "id" => "bit.ly/3Use6uj",
    "long_url" => "https://rubyonrails.org"
  }.to_json
  WebMock::API.stub_request(:post, "https://api-ssl.bitly.com/v4/shorten")
    .to_return(status: 200, body: mocked_response, headers: {"content-type" => "application/json"})
end

================
File: Chapter04/assets/logo.svg
================
<svg width="115" height="31" viewBox="0 0 115 31" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M108.211 5.89722H102.542L109.79 14.7434L102.542 23.5896H108.211L115 14.7434L108.211 5.89722Z" fill="#FA7040"/>
<path d="M83.4517 5.89722H89.1242L81.8789 14.7434L89.1242 23.5896H83.4517L76.6659 14.7434L83.4517 5.89722Z" fill="#FA7040"/>
<path d="M6.78901 5.89722H12.4583L5.20962 14.7434L12.4583 23.5896H6.78901L0 14.7434L6.78901 5.89722Z" fill="#FA7040"/>
<path d="M46.0506 18.721C45.2265 19.625 44.1491 20.077 42.8246 20.077C41.9533 20.077 41.188 19.8721 40.5228 19.4623C39.8576 19.0525 39.3395 18.486 38.9628 17.7569C38.586 17.0277 38.3976 16.178 38.3976 15.2138C38.3976 14.2496 38.586 13.436 38.9628 12.7069C39.3395 11.9777 39.8576 11.4052 40.5228 11.0014C41.188 10.5917 41.9533 10.3868 42.8246 10.3868C43.6959 10.3868 44.4965 10.5917 45.1676 11.0014C45.8328 11.4112 46.3509 11.9777 46.7276 12.7069C47.1044 13.436 47.2928 14.2737 47.2928 15.2138C47.2928 16.648 46.8807 17.8171 46.0565 18.721H46.0506ZM47.0337 7.97627C46.551 7.45199 45.9859 7.0181 45.3265 6.6746C44.3375 6.15634 43.2072 5.89722 41.9533 5.89722C40.358 5.89722 38.9157 6.307 37.6382 7.12054C36.3548 7.94011 35.3541 9.04894 34.63 10.4591C33.9059 11.8692 33.5409 13.4662 33.5409 15.2499C33.5409 17.0337 33.9059 18.5945 34.63 20.0046C35.3541 21.4148 36.3607 22.5296 37.6382 23.3492C38.9216 24.1688 40.358 24.5725 41.9533 24.5725C43.2072 24.5725 44.3316 24.3074 45.3265 23.771C45.9859 23.4155 46.551 22.9816 47.0337 22.4573V24.1929H51.7492V6.25879H47.0337V7.97024V7.97627Z" fill="#FA7040"/>
<path d="M65.2342 19.6285C64.5938 19.9112 63.877 20.0556 63.078 20.0556C62.2085 20.0556 61.433 19.8511 60.7456 19.4421C60.0582 19.0331 59.5177 18.4677 59.1182 17.7399C58.7187 17.0122 58.519 16.1762 58.519 15.2379C58.519 14.2996 58.7187 13.4395 59.1182 12.7358C59.5177 12.0321 60.0582 11.4788 60.7456 11.0698C61.433 10.6608 62.2085 10.4563 63.078 10.4563C63.8477 10.4563 64.5586 10.5946 65.1931 10.8653C65.8334 11.1359 66.3798 11.5329 66.8381 12.0501L69.8814 8.8985C69.0354 7.93616 68.0366 7.19637 66.8792 6.6731C65.7218 6.15584 64.4528 5.89722 63.078 5.89722C61.3155 5.89722 59.7175 6.31222 58.284 7.13622C56.8446 7.96624 55.7165 9.07894 54.8999 10.4924C54.0774 11.8998 53.6661 13.4936 53.6661 15.274C53.6661 17.0543 54.0774 18.6121 54.8999 20.0195C55.7224 21.4269 56.8446 22.5396 58.2663 23.3516C59.6881 24.1695 61.292 24.5725 63.078 24.5725C64.4528 24.5725 65.7218 24.3139 66.8792 23.7966C68.0366 23.2794 69.0647 22.5216 69.9578 21.5352L66.8792 18.3835C66.421 18.9248 65.8687 19.3398 65.2342 19.6225" fill="#FA7040"/>
<path d="M76.6668 14.4873V0H71.8752V23.5899H76.6668V15.4271" fill="#FA7040"/>
<path d="M98.2907 0H93.3692V6.02583H89.1247V10.2103H93.3692V23.5899H98.2907V10.2103H102.541V6.02583H98.2907V0Z" fill="#FA7040"/>
<path d="M26.2015 17.9209C25.8247 18.6602 25.3005 19.2406 24.6233 19.656C23.9461 20.0715 23.1747 20.2792 22.3031 20.2792C21.4316 20.2792 20.666 20.0715 20.0006 19.656C19.3352 19.2406 18.8169 18.6663 18.44 17.9209C18.0632 17.1816 17.8747 16.3202 17.8747 15.3426C17.8747 14.3651 18.0632 13.5403 18.44 12.8011C18.8169 12.0618 19.341 11.4814 20.0183 11.072C20.6955 10.6566 21.4551 10.4489 22.3031 10.4489C23.1511 10.4489 23.9461 10.6566 24.6233 11.072C25.3005 11.4875 25.8247 12.0618 26.2015 12.8011C26.5784 13.5403 26.7669 14.3895 26.7669 15.3426C26.7669 16.2957 26.5784 17.1816 26.2015 17.9209ZM27.4912 7.13746C26.2074 6.31267 24.7588 5.89722 23.1393 5.89722C21.8791 5.89722 20.7485 6.17215 19.7474 6.72201C19.1526 7.05193 18.6285 7.44905 18.1692 7.90727V6.15993H13.4169V30.47H18.1338V22.8452C18.5932 23.3034 19.1232 23.6945 19.7297 24.0183C20.7426 24.5559 21.8791 24.8308 23.1393 24.8308C24.7588 24.8308 26.2133 24.4154 27.4912 23.5906C28.775 22.7597 29.7819 21.6355 30.5181 20.1998C31.2542 18.7701 31.6252 17.1633 31.6252 15.3793C31.6252 13.5953 31.2542 11.9518 30.5181 10.5222C29.7819 9.09253 28.7691 7.96226 27.4912 7.13135" fill="#FA7040"/>
</svg>

================
File: Chapter04/views/posts/show.html.erb
================
<div id="<%= dom_id(@post)%>">
  <h2><%= @post.title %>
</div>

================
File: Chapter04/00-posts-controller-callbacks.rb
================
require_relative "./prelude"
using ChapterHelpers
class PostsController < ApplicationController
  before_action :authenticate!
  before_action :load_post, only: [:show, :update]
  after_action :track_post_view, only: [:show]
  def update
    if @post.update(post_params)
      redirect_to @post
    else
      render action: :edit
    end
  end
  private
  def load_post = @post = Post.find(params[:id])
  def track_post_view
    # e.g., enqueue a background job from here
  end
  def post_params = params.require(:post).permit(:title, :content)
end
post = Post.create!(title: "Layering Rails", content: "Rails is a framework")
patch "/posts/#{post.id}", params: {post: {content: "Rails is an onion"}}
puts post.reload.content

================
File: Chapter04/01-posts-controller-callbackless.rb
================
require_relative "./prelude"
using ChapterHelpers
class PostsController < ApplicationController
  def show
    authenticate!
    @post = Post.find(params[:id])
    track_post_view
  end
  def update
    authenticate!
    @post = Post.find(params[:id])
    if @post.update(post_params)
      redirect_to @post
    else
      render action: :edit
    end
  end
  private
  def track_post_view
    # e.g., enqueue a background job from here
  end
  def post_params = params.require(:post).permit(:title, :content)
end
post = Post.create!(title: "Layering Rails", content: "Rails is a framework")
patch "/posts/#{post.id}", params: {post: {content: "Rails is an onion"}}
puts post.reload.content

================
File: Chapter04/02-contextual-controller-callbacks.rb
================
require_relative "./prelude"
using ChapterHelpers
# Application controller with around callbacks to set up
# the request local and time zone
class ApplicationController < ActionController::Base
  around_action :with_current_locale
  around_action :with_current_tz, if: :current_user
  private
  def with_current_locale(&)
    locale = params[:locale] || current_user&.locale || I18n.default_locale
    I18n.with_locale(locale, &)
  end
  def with_current_tz(&)
    Time.use_zone(current_user.time_zone, &)
  end
  # Dummy current_user implementation
  def current_user
    OpenStruct.new(locale: params[:lang], time_zone: params[:tz])
  end
end
# Dummy controller to see contextual callbacks in action
class DemosController < ApplicationController
  def show
    render inline: t("current_time", time: Time.zone.now)
  end
end
response = get "/demo?lang=en&tz=America/New_York"
puts response.body
response = get "/demo?lang=ru&tz=Asia/Magadan"
puts response.body

================
File: Chapter04/03-controller-authentication-callback-hidden-dependency.rb
================
require_relative "./prelude"
using ChapterHelpers
class ApplicationController < ActionController::Base
  before_action :authenticate!
  private
  def authenticate!
    current_user || redirect_to(login_path)
  end
  def current_user
    @current_user ||= User.find_by(id: params[:user_id])
  end
end
class PostsController < ApplicationController
  before_action :load_post
  skip_before_action :authenticate!, only: [:show]
  def show
    authenticate! unless @post.is_public?
  end
  private
  def load_post = @post = Post.find(params[:id])
end
user = User.create!(name: "Vova")
post = Post.create!(title: "Layering Rails 2", content: "Rails is more than a framework", is_public: false)
# Authenticated request
response = get "/posts/#{post.id}?user_id=#{user.id}"
puts response.body
# Unauthenticated request
response = get "/posts/#{post.id}"
puts response.body
# Add new application-level callback relying on the authencation
class ApplicationController
  after_action :track_page_view
  private
  def track_page_view
    current_user.track_page_view!(request.path)
  end
end
# Authenticated request succeeds as before
response = get "/posts/#{post.id}?user_id=#{user.id}"
puts response.body
# Unauthenticated request now raises an exception
begin
  get "/posts/#{post.id}"
rescue => err
  puts "#{err.class}: #{err.message}"
end

================
File: Chapter04/04-activerecord-callbacks.rb
================
require_relative "./prelude"
p ActiveRecord::Callbacks::CALLBACKS

================
File: Chapter04/05-user-callbacks.rb
================
require_relative "./prelude"
class User < ApplicationRecord
  after_commit :send_welcome_email, on: :create
  private
  def send_welcome_email
    UserMailer.welcome(self).deliver_later
  end
end
User.create!(name: "Vova")
# Define more callbacks
class User < ApplicationRecord
  after_create :generate_initial_project
  after_commit :send_welcome_email, on: :create
  after_commit :send_analytics_event, on: :create
  after_commit :sync_with_crm
  private
  def generate_initial_project
    puts "[INTERNAL] Generate project for #{name} (#{id})"
  end
  def send_analytics_event
    puts "[ANALYTICS] User created: ID=#{id}"
  end
  def sync_with_crm
    puts "[CRM] Create user: NAME=#{name}"
  end
end
User.create!(name: "John")
# Add conditions to some callbacks
class User < ApplicationRecord
  after_create :generate_initial_project, unless: :admin?
  after_commit :send_welcome_email, on: :create
  after_commit :send_analytics_event,
    on: :create, if: :tracking_consent?
  after_commit :sync_with_crm
end
User.create!(name: "Non-admin without consent", admin: false, tracking_consent: false)
User.create!(name: "Non-admin with consent", admin: false, tracking_consent: true)
User.create!(name: "Admin without consent", admin: true, tracking_consent: false)
# Add virtual attributes to skip callbacks
class User < ApplicationRecord
  attr_accessor :skip_welcome_email, :skip_crm_sync
  after_create :generate_initial_project, unless: :admin?
  after_commit :send_welcome_email,
    on: :create, unless: :skip_welcome_email
  after_commit :send_analytics_event,
    on: :create, if: :tracking_consent?
  after_commit :sync_with_crm, unless: :skip_crm_sync
end
User.create!(name: "Non-admin with consent",
  admin: false, tracking_consent: true,
  skip_crm_sync: true, skip_welcome_email: true)

================
File: Chapter04/06-post-transforming-callbacks.rb
================
require_relative "./prelude"
class Post < ApplicationRecord
  before_validation :compute_shortname, on: :create
  before_validation :squish_content, if: :content_changed?
  before_save :set_word_count, if: :content_changed?
  validates :short_name, :content, :word_count,
    presence: true
  private
  def compute_shortname
    self.short_name ||= title.parameterize
  end
  def squish_content
    content.squish!
  end
  def set_word_count
    self.word_count = content.split(/\s+/).size
  end
end
post = Post.create!(title: "Layering Rails", content: "A book of callbacks")
puts post.attributes
# Rails 7.1 normalization API example
class NormalizedPost < ApplicationRecord
  self.table_name = "posts"
  normalizes :content, with: -> { _1.squish }
end
post = NormalizedPost.create!(title: "Layering Rails 7.1", content: " A book of\n normalizations  ")
puts post.content

================
File: Chapter04/07-comment-utility-callbacks.rb
================
require_relative "./prelude"
using ChapterHelpers
class Post
  has_many :comments, inverse_of: :post
end
class Comment < ApplicationRecord
  belongs_to :post, touch: true, counter_cache: true
end
post = Post.create!(title: "Rails is back", content: "Or is it?")
puts post.attributes.slice("comments_count", "updated_at")
# Add some sleep to see the #updated_at changes
sleep 1
post.comments.create(body: "Sure it is!")
# Reload record to reflect changes (e.g., updated_at)
puts post.reload.attributes.slice("comments_count", "updated_at")
# Re-create the Comment class and define the utility callbacks manually
remove_const(:Comment)
class Comment < ApplicationRecord
  belongs_to :post
  after_save { post.touch }
  after_create do
    Post.increment_counter(:comments_count, post_id)
  end
  after_destroy do
    Post.decrement_counter(:comments_count, post_id)
  end
end
# Add some sleep to see the #updated_at changes
sleep 1
post.comments.create(body: "Glad to hear that")
# Reload record to reflect changes (e.g., updated_at)
puts post.reload.attributes.slice("comments_count", "updated_at")

================
File: Chapter04/08-user-events-subscriber.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  after_commit do
    ActiveSupport::Notifications.instrument(
      "updated.user",
      {user: self}
    )
  end
end
user = User.create!(name: "John")
class UserCRMSubscriber < ActiveSupport::Subscriber
  def updated(event)
    user = event.payload[:user]
    puts "User updated: #{user.name}"
  end
end
UserCRMSubscriber.attach_to :user
user.update!(name: "Vova")

================
File: Chapter04/09-soft-deletable-concern.rb
================
require_relative "./prelude"
module SoftDeletable
  extend ActiveSupport::Concern
  include Discard::Model
  included do
    self.discard_column = :deleted_at
    belongs_to :deleted_by, class_name: "User",
      optional: true
  end
  def discard(by: Current.user)
    self.deleted_by = by
    super()
  end
end
class Post < ApplicationRecord
  include SoftDeletable
end
user = User.create!(name: "Deleter")
post = Post.create!(title: "Delete me!", content: "TBD")
post.discard(by: user)
post.discarded?
post.deleted_by.name

================
File: Chapter04/10-soft-deletable-module.rb
================
require_relative "./prelude"
# Pure Ruby module soft-deletable implementation
module SoftDeletable
  def self.included(base)
    base.include Discard::Model
    base.discard_column = :deleted_at
    base.belongs_to :deleted_by, class_name: "User",
      optional: true
    base.include InstanceMethods
  end
  module InstanceMethods
    def discard(by: Current.user)
      self.deleted_by = by
      super()
    end
  end
end
class Post < ApplicationRecord
  include SoftDeletable
end
user = User.create!(name: "Deleter")
post = Post.create!(title: "Delete me!", content: "TBD")
post.discard(by: user)
post.discarded?
post.deleted_by.name

================
File: Chapter04/11-user-authentication-behavior.rb
================
require_relative "./prelude"
class User < ApplicationRecord
  has_secure_password
  def self.authenticate_by(email:, password:)
    find_by(email:)&.authenticate(password)
  end
end
user = User.create!(
  name: "Secret User", email: "secret@example.com",
  password: "secret", password_confirmation: "secret"
)
authenticated_user = User.authenticate_by(email: "secret@example.com", password: "secret")
user == authenticated_user

================
File: Chapter04/12-user-authentication-concern.rb
================
require_relative "./prelude"
# Extract user authentication concern into app/concerns/user/authentication.rb
module User::Authentication
  extend ActiveSupport::Concern
  included do
    has_secure_password
  end
  class_methods do
    def authenticate_by(email:, password:)
      find_by(email:)&.authenticate(password)
    end
  end
end
class User < ApplicationRecord
  include Authentication
end
user = User.create!(
  name: "Secret User", email: "secret@example.com",
  password: "secret", password_confirmation: "secret"
)
authenticated_user = User.authenticate_by(email: "secret@example.com", password: "secret")
user == authenticated_user

================
File: Chapter04/13-contactable-concern.rb
================
require_relative "./prelude"
module Contactable
  extend ActiveSupport::Concern
  SOCIAL_ACCOUNTS = %i[facebook twitter tiktok].freeze
  included do
    store_accessor :social_accounts, *SOCIAL_ACCOUNTS,
      suffix: :social_id
    validates :phone_number, allow_blank: true,
      phone: {types: :mobile}
    validates :country_code, inclusion: Country.codes
    before_validation :normalize_phone_number,
      if: :phone_number_changed?
  end
  def region = Country[country_code].region
  def phone_number_visible?
    contact_info_visible && phone_number_visible
  end
  def normalize_phone_number
    return unless phone_number.present?
    self.phone_number = Phonelib.parse(phone_number).e164
  end
end
class User < ApplicationRecord
  include Contactable
end
user = User.new(
  name: "Alice", country_code: "US", phone_number: "+1 (234) 444-5555",
  twitter_social_id: "alice555"
)
user.save!
puts user.phone_number
puts user.region

================
File: Chapter04/14-contact-information-delegate-object.rb
================
require_relative "./prelude"
class ContactInformation < ApplicationRecord
  belongs_to :contactable, polymorphic: true
  SOCIAL_ACCOUNTS = %i[facebook twitter tiktok].freeze
  store_accessor :social_accounts, *SOCIAL_ACCOUNTS,
    suffix: :social_id
  validates :phone_number, allow_blank: true,
    phone: {types: :mobile}
  validates :country_code, inclusion: Country.codes
  before_validation :normalize_phone_number,
    if: :phone_number_changed?
  def region
    Country[country_code].region
  end
  private
  def phone_number_visible?
    contact_info_visible && phone_number_visible
  end
  def normalize_phone_number
    return unless phone_number.present?
    self.phone_number = Phonelib.parse(phone_number).e164
  end
end
module Contactable
  extend ActiveSupport::Concern
  included do
    has_one :contact_information, as: :contactable,
      dependent: :destroy
    delegate :phone_number, :region,
      to: :contact_information
  end
end
class User < ApplicationRecord
  include Contactable
end
user = User.new(
  name: "Alice"
)
user.save!
user.create_contact_information(
  country_code: "US",
  phone_number: "+1 (234) 444-5555",
  twitter_social_id: "alice555"
)
puts user.phone_number
puts user.region

================
File: Chapter04/15-with-media-concern.rb
================
require_relative "./prelude"
module WithMedia
  extend ActiveSupport::Concern
  SVG_TYPES = %w[
    image/svg
    image/svg+xml
  ].freeze
  FONT_TYPES = %w[
    font/otf
    font/ttf
    font/woff
    font/woff2
  ].freeze
  included do
    has_one_attached :media
    delegate :video?, :audio?, to: :media
  end
  def font? = FONT_TYPES.include?(media.content_type)
  def svg? = SVG_TYPES.include?(media.content_type)
  # â€¦ more <type>? methods
end
class Post < ApplicationRecord
  include WithMedia
end
post = Post.create!(title: "Media assets", content: "Some svg")
post.media.attach(io: File.open(File.join(__dir__, "assets/logo.svg")), filename: "logo.svg")
post.svg?
post.font?

================
File: Chapter04/16-media-value-object.rb
================
require_relative "./prelude"
SVG_TYPES = %w[
  image/svg
  image/svg+xml
].freeze
FONT_TYPES = %w[
  font/otf
  font/ttf
  font/woff
  font/woff2
].freeze
MediaType = Data.define(:content_type) do
  include Comparable
  def <=>(other) = content_type <=> other.content_type
  def video? = content_type.start_with?("video")
  def svg? = SVG_TYPES.include?(content_type)
  def font? = FONT_TYPES.include?(content_type)
  # â€¦ more <type>? methods
end
module WithMedia
  extend ActiveSupport::Concern
  included do
    has_one_attached :media
  end
  def media_type
    return unless media&.content_type
    MediaType.new(media.content_type)
  end
end
class Post < ApplicationRecord
  include WithMedia
end
post = Post.create!(title: "Media assets", content: "Some svg")
post.media.attach(io: File.open(File.join(__dir__, "assets/logo.svg")), filename: "logo.svg")
post.media_type.svg?
post.media_type.font?

================
File: Chapter04/17-current-attributes-posts.rb
================
require_relative "./prelude"
using ChapterHelpers
class Current < ActiveSupport::CurrentAttributes
  attribute :user
end
class ApplicationController < ActionController::Base
  before_action :set_current_user
  private
  def set_current_user
    Current.user = User.find_by(id: cookies[:user_id])
  end
end
# Phase 1: Soft-deleting posts and storing the information about the
# deleter user
class PostsController < ApplicationController
  def destroy
    post = Post.find(params[:id])
    post.destroy!
    redirect_to posts_path
  end
end
class Post < ApplicationRecord
  include Discard::Model
  self.discard_column = :deleted_at
  belongs_to :deleted_by, class_name: "User",
    optional: true
  def destroy
    self.deleted_by = Current.user
    discard
  end
end
user = User.create!(name: "Vova", email: "vova@example.com")
post = Post.create!(title: "To delete or not to delete", content: "Delete, please")
response = delete "/posts/#{post.id}", cookies: {user_id: user.id}
response.status
puts "Deleted by: #{post.reload.deleted_by&.name}"
# # Phase 2: Moving post.destroy to a background job
class PostsController < ApplicationController
  def destroy
    post = Post.find(params[:id])
    PostDeleteJob.perform_later(post)
    redirect_to posts_path
  end
end
class PostDeleteJob < ApplicationJob
  def perform(post) = post.destroy!
end
post = Post.create!(title: "Delete it again", content: "Delete, please")
response = delete "/posts/#{post.id}", cookies: {user_id: user.id}
response.status
puts "Deleted by: #{post.reload.deleted_by&.name}"
# Phase 3: Adding #destroy_all action to destroy multiple posts in a single request
class PostsController < ApplicationController
  def destroy_all
    Post.where(id: params[:ids]).destroy_all
    redirect_to posts_path
  end
end
# Adding email notifications after deletion
class Post < ApplicationRecord
  belongs_to :user
  belongs_to :deleted_by, class_name: "User",
    optional: true
  after_discard :notify_author
  def destroy
    self.deleted_by = Current.user
    discard
  end
  private
  def notify_author
    Current.user = user
    PostMailer.notify_deleted(self).deliver_now
  end
end
# The mailer class uses Current.user as a target user
class PostMailer < ApplicationMailer
  default to: -> { Current.user&.email }
  def notify_deleted(post)
    mail(
      subject: "Post deleted: #{post.title}",
      body: "Deleted by #{post.deleted_by&.name}"
    )
  end
end
alice = User.create!(name: "Alice", email: "alice@example.com")
bob = User.create!(name: "Bob", email: "bob@example.com")
post_a = Post.create!(title: "Post A", content: "Delete, please", user: alice)
post_b = Post.create!(title: "Post B", content: "Delete, please", user: bob)
# Delete multiple post and see the emails being sent: they should both indicate that
# the posts were deleted by Vova, but...
response = delete "/posts?ids[]=#{post_a.id}&ids[]=#{post_b.id}", cookies: {user_id: user.id}
response.status
# Fix #1: Use Current.set(...) to avoid leaking global state
class Post < ApplicationRecord
  # ...
  private
  def notify_author
    Current.set(user:) do
      PostMailer.notify_deleted(self).deliver_now
    end
  end
end
post_a = Post.create!(title: "Post A", content: "Delete, please", user: alice)
post_b = Post.create!(title: "Post B", content: "Delete, please", user: bob)
# Now the deleted_by is set correctly and reflected in the emails
response = delete "/posts?ids[]=#{post_a.id}&ids[]=#{post_b.id}", cookies: {user_id: user.id}
response.status
# Fix #2: Pass user explicitly, avoid global state
class PostsController < ApplicationController
  def destroy_all
    Post.where(id: params[:ids]).each { _1.destroy_by(Current.user) }
    redirect_to posts_path
  end
end
class Post < ApplicationRecord
  def destroy_by(user = nil)
    self.deleted_by = user
    discard
  end
  private
  def notify_author
    PostMailer.notify_deleted(user, self).deliver_now
  end
end
class PostMailer < ApplicationMailer
  def notify_deleted(user, post)
    mail(
      to: user.email,
      subject: "Post deleted: #{post.title}",
      body: "Deleted by #{post.deleted_by&.name}"
    )
  end
end
post_c = Post.create!(title: "Post C", content: "Delete, please", user: alice)
post_d = Post.create!(title: "Post D", content: "Delete, please", user: bob)
# Now the deleted_by is set correctly and reflected in the emails
response = delete "/posts?ids[]=#{post_c.id}&ids[]=#{post_d.id}", cookies: {user_id: user.id}
response.status

================
File: Chapter04/prelude.rb
================
# frozen_string_literal: true
require_relative "../lib/helpers"
using ChapterHelpers
gems do
  # For SoftDeletable example
  gem "discard", "1.2.1"
  # For authentication examples
  gem "bcrypt", "3.1.18"
  # For contactable examples
  gem "countries", "5.2.0"
  gem "phonelib", "0.7.5"
end
schema do
  create_table :posts, force: true do |t|
    t.string :title, null: false
    t.text :content, null: false
    t.belongs_to :user, null: true
    t.string :short_name, null: true
    t.integer :word_count, null: false, default: 0
    t.integer :comments_count, null: false, default: 0
    t.boolean :is_public, null: false, default: true
    t.datetime :deleted_at, null: true
    t.integer :deleted_by_id, null: true
    t.timestamps null: true
  end
  create_table :comments, force: true do |t|
    t.text :body, null: false
    t.belongs_to :post
    t.timestamps null: true
  end
  create_table :users, force: true do |t|
    t.string :name, null: true
    t.string :email, null: true
    t.string :password_digest, null: true
    t.boolean :admin, null: false, default: false
    t.boolean :tracking_consent, null: false, default: false
    t.json :social_accounts
    t.string :phone_number
    t.string :country_code
    t.boolean :phone_number_visible, null: false, default: true
    t.boolean :contact_info_visible, null: false, default: true
  end
  create_table :contact_informations, force: true do |t|
    t.belongs_to :contactable, polymorphic: true
    t.json :social_accounts
    t.string :phone_number
    t.string :country_code
    t.boolean :phone_number_visible, null: false, default: true
    t.boolean :contact_info_visible, null: false, default: true
  end
end
routes do
  resources :posts, only: [:show, :update, :destroy, :index] do
    delete "/", to: "posts#destroy_all", on: :collection
  end
  resource :demo, only: [:show]
  get "/_/login" => "welcome#index", :as => :login
end
require_relative "../lib/boot"
require "countries/global"
ISO3166.configure do |config|
  config.locales = [:en]
end
class Post < ApplicationRecord
end
class User < ApplicationRecord
  def track_page_view!(_path)
  end
end
class ApplicationController
  private
  def authenticate!
  end
end
class UserMailer < ApplicationMailer
  def welcome(user)
    mail(
      to: "user-#{user.id}@test.local",
      subject: "Welcome!",
      body: "Welcome, #{user.name}!"
    )
  end
end
# Add translations for contextual callbacks demo
I18n.backend.store_translations(:en, current_time: "Current time is %{time}")
I18n.backend.store_translations(:ru, current_time: "ÐœÐµÑÑ‚Ð½Ð¾Ðµ Ð²Ñ€ÐµÐ¼Ñ: %{time}")

================
File: Chapter05/00-githooks-controller-fat.rb
================
require_relative "./prelude"
class GithooksController < ApplicationController
  rescue_from JSON::ParserError do
    head :unprocessable_entity
  end
  def create
    verify_signature!
    event = parse_event request.raw_post
    case event
    in type: "issue", action: "opened",
       issue: {user: {login:}, title:, body:}
      track_issue(login, title, body)
    in type: "pull_request", action: "opened",
       pull_request: {
         user: {login:}, base: {label:}, title:, body:
       }
      track_pr(login, title, body, label)
    end
    head :ok
  end
  def verify_signature!
    # Letâ€™s skip the payload signature verification
    # code, since itâ€™s irrelevant to our refactoring
  end
  def parse_event(payload)
    JSON.parse(payload, symbolize_names: true)
  end
  def track_issue(login, title, body)
    User.find_by(gh_id: login)
        &.issues&.create!(title:, body:)
  end
  def track_pr(login, title, body, branch)
    User.find_by(gh_id: login)
        &.pull_requests&.create!(title:, body:, branch:)
  end
end
require_relative "githooks_controller_spec"
RSpec::Core::Runner.run([])

================
File: Chapter05/01-githooks-controller-thin.rb
================
require_relative "./prelude"
# Create new model to represent GitHub events
class GitHubEvent
  def self.parse(raw_event)
    parsed = JSON.parse(raw_event, symbolize_names: true)
    case parsed[:type]
    when "issue"
      Issue.new(
        user_id: parsed.dig(:issue, :user, :login),
        action: parsed[:action],
        **parsed[:issue].slice(:title, :body)
      )
    when "pull_request"
      PR.new(
        user_id: parsed.dig(:pull_request, :user, :login),
        action: parsed[:action],
        branch: parsed.dig(:pull_request, :base, :label),
        **parsed[:pull_request].slice(:title, :body)
      )
    end
  rescue JSON::ParserError
    nil
  end
  Issue = Data.define(:user_id, :action, :title, :body)
  PR = Data.define(
    :user_id, :action, :title, :body, :branch
  )
end
# Add a method to the model implementing webhooks processing logic
class User < ApplicationRecord
  def handle_github_event(event)
    case event
    in GitHubEvent::Issue[action: "opened", title:, body:]
      issues.create!(title:, body:)
    in GitHubEvent::PR[
      action: "opened", title:, body:, branch:
    ]
      pull_requests.create!(title:, body:, branch:)
    end
  end
end
class GithooksController < ApplicationController
  def create
    verify_signature!
    event = GitHubEvent.parse(request.raw_post)
    return head :unprocessable_entity if event.nil?
    user = User.find_by(gh_id: event.user_id)
    user&.handle_github_event(event)
    head :ok
  end
  def verify_signature!
    # Letâ€™s skip the payload signature verification
    # code, since itâ€™s irrelevant to our refactoring
  end
end
# Tests for the thin controller stay the same
require_relative "githooks_controller_spec"
RSpec::Core::Runner.run([])

================
File: Chapter05/02-githooks-controller-service-initial.rb
================
require_relative "./prelude"
class GitHubEvent
  def self.parse(raw_event)
    parsed = JSON.parse(raw_event, symbolize_names: true)
    case parsed[:type]
    when "issue"
      Issue.new(
        user_id: parsed.dig(:issue, :user, :login),
        action: parsed[:action],
        **parsed[:issue].slice(:title, :body)
      )
    when "pull_request"
      PR.new(
        user_id: parsed.dig(:pull_request, :user, :login),
        action: parsed[:action],
        branch: parsed.dig(:pull_request, :base, :label),
        **parsed[:pull_request].slice(:title, :body)
      )
    end
  rescue JSON::ParserError
    nil
  end
  Issue = Data.define(:user_id, :action, :title, :body)
  PR = Data.define(
    :user_id, :action, :title, :body, :branch
  )
end
# Base class for service objects implementing Callbable interface
class ApplicationService
  extend Dry::Initializer
  def self.call(...) = new(...).call
end
# Service object responsible for processing GitHub webhooks
class User::HandleGithubEventService < ApplicationService
  param :user
  param :event
  def call
    case event
    in GitHubEvent::Issue[action: "opened", title:, body:]
      user.issues.create!(title:, body:)
    in GitHubEvent::PR[
      action: "opened", title:, body:, branch:
    ]
      user.pull_requests.create!(title:, body:, branch:)
    end
  end
end
class GithooksController < ApplicationController
  def create
    verify_signature!
    event = GitHubEvent.parse(request.raw_post)
    return head :unprocessable_entity if event.nil?
    user = User.find_by(gh_id: event.user_id)
    User::HandleGithubEventService.call(user, event) if user
    head :ok
  end
  def verify_signature!
    # Letâ€™s skip the payload signature verification
    # code, since itâ€™s irrelevant to our refactoring
  end
end
# At this refactoring stage, we still have to test all the cases.
# We could use mock chains (allow_any_instance_of(User).to ...), but that
# makes tests too close to implementation.
require_relative "githooks_controller_spec"
RSpec::Core::Runner.run([])

================
File: Chapter05/03-githooks-controller-service-final.rb
================
require_relative "./prelude"
class GitHubEvent
  def self.parse(raw_event)
    parsed = JSON.parse(raw_event, symbolize_names: true)
    case parsed[:type]
    when "issue"
      Issue.new(
        user_id: parsed.dig(:issue, :user, :login),
        action: parsed[:action],
        **parsed[:issue].slice(:title, :body)
      )
    when "pull_request"
      PR.new(
        user_id: parsed.dig(:pull_request, :user, :login),
        action: parsed[:action],
        branch: parsed.dig(:pull_request, :base, :label),
        **parsed[:pull_request].slice(:title, :body)
      )
    end
  rescue JSON::ParserError
    nil
  end
  Issue = Data.define(:user_id, :action, :title, :body)
  PR = Data.define(
    :user_id, :action, :title, :body, :branch
  )
end
# Base class for service objects implementing Callbable interface
class ApplicationService
  extend Dry::Initializer
  def self.call(...) = new(...).call
end
# Now we move service object out of the user namespace and
# leave only the event parameter
class HandleGithubEventService < ApplicationService
  param :event
  def call
    user = User.find_by(gh_id: event.user_id)
    return false unless user
    case event
    in GitHubEvent::Issue[action: "opened", title:, body:]
      user.issues.create!(title:, body:)
    in GitHubEvent::PR[
      action: "opened", title:, body:, branch:
    ]
      user.pull_requests.create!(title:, body:, branch:)
    else
      # ignore unknown events
    end
    true
  end
end
class GithooksController < ApplicationController
  def create
    verify_signature!
    event = GitHubEvent.parse(request.raw_post)
    return head :unprocessable_entity if event.nil?
    HandleGithubEventService.call(event)
    head :ok
  end
  def verify_signature!
    # Letâ€™s skip the payload signature verification
    # code, since itâ€™s irrelevant to our refactoring
  end
end
# Now we can update our tests tooâ€”no need to worry about users,
# no need to test all the event types, we can only verify that the right
# service is called with the expected parameters
require_relative "githooks_controller_service_spec"
RSpec::Core::Runner.run([])

================
File: Chapter05/04-githooks-controller-service-cross-layer.rb
================
require_relative "./prelude"
class GitHubEvent
  def self.parse(raw_event)
    parsed = JSON.parse(raw_event, symbolize_names: true)
    case parsed[:type]
    when "issue"
      Issue.new(
        user_id: parsed.dig(:issue, :user, :login),
        action: parsed[:action],
        **parsed[:issue].slice(:title, :body)
      )
    when "pull_request"
      PR.new(
        user_id: parsed.dig(:pull_request, :user, :login),
        action: parsed[:action],
        branch: parsed.dig(:pull_request, :base, :label),
        **parsed[:pull_request].slice(:title, :body)
      )
    end
  rescue JSON::ParserError
    nil
  end
  Issue = Data.define(:user_id, :action, :title, :body)
  PR = Data.define(
    :user_id, :action, :title, :body, :branch
  )
end
# Base class for service objects implementing Callbable interface
class ApplicationService
  extend Dry::Initializer
  def self.call(...) = new(...).call
end
# Updated service object responsible for processing GitHub webhooks.
# Now it accepts the request object as input. This makes it dependent on the
# presentation layer.
class HandleGithubEventService < ApplicationService
  param :request
  def call
    event = GitHubEvent.parse(request.raw_post)
    return false unless event
    user = User.find_by(gh_id: event.user_id)
    return true unless user
    case event
    in GitHubEvent::Issue[action: "opened", title:, body:]
      user.issues.create!(title:, body:)
    in GitHubEvent::PR[
      action: "opened", title:, body:, branch:
    ]
      user.pull_requests.create!(title:, body:, branch:)
    else
      # ignore unknown events
    end
    true
  end
end
class GithooksController < ApplicationController
  def create
    verify_signature!
    if HandleGithubEventService.call(request)
      head :ok
    else
      head :unprocessable_entity
    end
  end
  def verify_signature!
    # Letâ€™s skip the payload signature verification
    # code, since itâ€™s irrelevant to our refactoring
  end
end
require_relative "githooks_controller_spec"
RSpec::Core::Runner.run([])

================
File: Chapter05/githooks_controller_service_spec.rb
================
require_relative "rails_helper"
RSpec.describe GithooksController, type: :request do
  let(:raw_event) { '{"event":"test"}' }
  let(:event) { GitHubEvent::Issue.new(user_id: "palkan", action: "opened", title: "Issue", body: "Test") }
  let!(:user) { User.create!(name: "Vova", gh_id: "palkan") }
  before do
    allow(GitHubEvent).to receive(:parse).and_return(event)
    # Call original to make sure the happy path is fully covered with tests
    allow(HandleGithubEventService).to receive(:call).and_call_original
  end
  subject { post "/callbacks/github", params: raw_event }
  it "creates an issue for user via HandleGithubEventService", :aggregate_failures do
    expect { subject }.to change(user.issues, :count).by(1)
    expect(response.status).to eq(200)
    expect(GitHubEvent).to have_received(:parse).with(raw_event)
    expect(HandleGithubEventService).to have_received(:call).with(event)
  end
  context "when service cannot process the event" do
    before { allow(GitHubEvent).to receive(:parse).and_return(nil) }
    it "returns 422" do
      subject
      expect(response.status).to eq(422)
    end
  end
  context "when signature is missing"
  context "when signature is invalid"
end

================
File: Chapter05/githooks_controller_spec.rb
================
require_relative "rails_helper"
# Tests for the fat controller
RSpec.describe GithooksController, type: :request do
  let(:event) { ISSUE_PAYLOAD }
  let!(:user) { User.create!(name: "Vova", gh_id: "palkan") }
  subject { post "/callbacks/github", params: event }
  context "when event is issue" do
    it "creates an issue for user", :aggregate_failures do
      expect { subject }.to change(user.issues, :count).by(1)
      expect(response.status).to eq(200)
    end
  end
  context "when event is pull_request" do
    let(:event) { PR_PAYLOAD }
    it "creates an issue for user", :aggregate_failures do
      expect { subject }.to change(user.pull_requests, :count).by(1)
      expect(response.status).to eq(200)
    end
  end
  context "when user is not found" do
    before { user.destroy }
    specify do
      subject
      expect(response.status).to eq(200)
    end
  end
  context "when payload is not JSON" do
    let(:event) { "some_event" }
    it "responds with 422" do
      subject
      expect(response.status).to eq(422)
    end
  end
  context "when signature is missing"
  context "when signature is invalid"
end

================
File: Chapter05/prelude.rb
================
# frozen_string_literal: true
require_relative "../lib/helpers"
using ChapterHelpers
gems do
  # For service objects
  gem "dry-initializer", "3.1.1"
  # For specifications
  gem "rspec-rails", "6.1.0"
end
schema do
  create_table :users, force: true do |t|
    t.string :name, null: false
    t.string :gh_id, null: false
    t.timestamps null: true
  end
  create_table :issues, force: true do |t|
    t.belongs_to :user
    t.string :title, null: false
    t.text :body
    t.timestamps null: true
  end
  create_table :pull_requests, force: true do |t|
    t.belongs_to :user
    t.string :title, null: false
    t.text :body
    t.string :branch
    t.timestamps null: true
  end
end
routes do
  post "/callbacks/github", to: "githooks#create"
end
require_relative "../lib/boot"
class User < ApplicationRecord
  has_many :issues
  has_many :pull_requests
end
class Issue < ApplicationRecord
  belongs_to :user
end
class PullRequest < ApplicationRecord
  belongs_to :user
end
ISSUE_PAYLOAD = {
  type: "issue", action: "opened",
  issue: {user: {login: "palkan"}, title: "Slimming down controllers", body: "Let's do that"}
}.to_json.freeze
PR_PAYLOAD = {
  type: "pull_request", action: "opened",
  pull_request: {user: {login: "palkan"}, base: {label: "feat/slim"}, title: "Slim down controllers", body: "Let's do that"}
}.to_json.freeze

================
File: Chapter05/rails_helper.rb
================
# frozen_string_literal: true
require "rspec/rails"
RSpec.configure do |config|
  config.use_transactional_fixtures = true
end

================
File: Chapter06/00-user-with-bookmarked-posts.rb
================
require_relative "./prelude"
# Populating data
user = User.create!(name: "Vova")
alice = User.create!(name: "Alice")
post = alice.posts.create(title: "Query Objects on Rails", created_at: Time.current.prev_week)
user.bookmarks.create!(post:)
Post.where(draft: false).order(created_at: :desc)
User.with(
  bookmarked_posts: Post
      .where(created_at: Date.current.prev_week.all_week)
      .where.associated(:bookmarks)
      .select(:user_id).distinct
).joins(:bookmarked_posts)
class Post < ApplicationRecord
  scope :ordered, -> { order(created_at: :desc) }
  scope :published, -> { where(draft: false) }
  scope :kept, -> { where(deleted_at: nil) }
  scope :previous_week, -> {
    where(created_at: Date.current.prev_week.all_week)
  }
end
# Now we use named scopes instead of explicit conditions
Post.kept.published.ordered
class User < ApplicationRecord
  def self.with_bookmarked_posts(period = :previous_week)
    bookmarked_posts =
      Post.public_send(period)
        .where.associated(:bookmarks)
        .select(:user_id).distinct
    with(bookmarked_posts:).joins(:bookmarked_posts)
  end
end
# Now we can use this query as follows
User.with_bookmarked_posts
# Extracting query into a separate object
class UserWithBookmarkedPostsQuery
  def call(period = :previous_week)
    bookmarked_posts =
      Post.public_send(period)
        .where.associated(:bookmarks)
        .select(:user_id).distinct
    User.with(bookmarked_posts:).joins(:bookmarked_posts)
  end
end
# Using query object
UserWithBookmarkedPostsQuery.new.call

================
File: Chapter06/01-application-query.rb
================
require_relative "./prelude"
# Populating data
user = User.create!(name: "Vova")
alice = User.create!(name: "Alice")
post = alice.posts.create(title: "Query Objects on Rails", created_at: Time.current.prev_week)
user.bookmarks.create!(post:)
post_2 = user.posts.create(title: "Active Record scopes", created_at: Time.current.prev_month)
alice.bookmarks.create!(post: post_2)
post_3 = alice.posts.create(title: "Active Record models", created_at: Time.current.prev_week)
user.bookmarks.create!(post: post_3)
# Add Post scopes
class Post < ApplicationRecord
  scope :previous_week, -> {
    where(created_at: Date.current.prev_week.all_week)
  }
  scope :previous_month, -> {
    where(created_at: Date.current.prev_month.all_month)
  }
end
# 1. Query object basic interface: naming
class ApplicationQuery
  def resolve(...) = raise NotImplementedError
end
# 2. Query object basic interface: method signatures
class ApplicationQuery
  private attr_reader :relation
  def initialize(relation) = @relation = relation
  def resolve(...) = relation
end
class UserWithBookmarkedPostsQuery < ApplicationQuery
  def resolve(period: :previous_week)
    bookmarked_posts = build_bookmarked_posts_scope(period)
    relation.with(bookmarked_posts:).joins(:bookmarked_posts)
  end
  private
  def build_bookmarked_posts_scope(period)
    return Post.none unless Post.respond_to?(period)
    Post.public_send(period)
      .where.associated(:bookmarks)
      .select(:user_id).distinct
  end
end
UserWithBookmarkedPostsQuery.new(User.all).resolve
UserWithBookmarkedPostsQuery.new(User.where(name: "Vova")).resolve
UserWithBookmarkedPostsQuery.new(User.where(name: "Vova")).resolve(period: :previous_month)
UserWithBookmarkedPostsQuery.new(User.all).resolve(period: :previous_month).where(name: "Vova")
class UserWithBookmarkedPostsQuery < ApplicationQuery
  def initialize(relation = User.all) = super(relation)
end
UserWithBookmarkedPostsQuery.new.resolve
class ApplicationQuery
  class << self
    def resolve(...) = new.resolve(...)
  end
end
UserWithBookmarkedPostsQuery.resolve
# 3. Inferring query model from a class name
class ApplicationQuery
  class << self
    def query_model
      name.sub(/::[^:]+$/, "").safe_constantize
    end
  end
  def initialize(relation = self.class.query_model.all)
    @relation = relation
  end
end
draft_post = Post.create!(title: "WIP", draft: true, user:)
class Post::DraftQuery < ApplicationQuery
  def resolve = relation.where(draft: true)
end
Post::DraftQuery.resolve

================
File: Chapter06/02-scopes.rb
================
require_relative "./prelude"
# Populating data
account = Account.create!(name: "Any Rails")
user = account.users.create(name: "Vova")
alice = account.users.create(name: "Alice")
post = alice.posts.create(title: "Query Objects on Rails", created_at: Time.current.prev_week)
user.bookmarks.create!(post:)
Post.insert_all([
  {title: "A", created_at: 1.day.ago},
  {title: "B", created_at: 1.hour.ago}
])
class Post < ApplicationRecord
  scope :ordered, -> { order(created_at: :desc) }
  scope :published, -> { where(draft: false) }
end
Post.published.order(title: :asc).pluck(:title)
# Adding .ordered to the .published scope
class Post < ApplicationRecord
  scope :ordered, -> { order(created_at: :desc) }
  scope :published, -> { ordered.where(draft: false) }
end
Post.published.order(title: :asc).pluck(:title)
# Query objects vs scopes
class User < ApplicationRecord
  def self.with_bookmarked_posts(period = :previous_week)
    bookmarked_posts =
      Post.public_send(period)
        .where.associated(:bookmarks)
        .select(:user_id).distinct
    with(bookmarked_posts:).joins(:bookmarked_posts)
  end
end
# Add Post scopes
class Post < ApplicationRecord
  scope :previous_week, -> {
    where(created_at: Date.current.prev_week.all_week)
  }
  scope :previous_month, -> {
    where(created_at: Date.current.prev_month.all_month)
  }
end
class ApplicationQuery
  class << self
    def query_model
      name.sub(/::[^:]+$/, "").safe_constantize
    end
    def resolve(...) = new.resolve(...)
    alias_method :call, :resolve
  end
  private attr_reader :relation
  def initialize(relation = self.class.query_model.all)
    @relation = relation
  end
  def resolve(...) = relation
end
class User::WithBookmarkedPostsQuery < ApplicationQuery
  def resolve(period: :previous_week)
    bookmarked_posts = build_bookmarked_posts_scope(period)
    relation.with(bookmarked_posts:).joins(:bookmarked_posts)
  end
  private
  def build_bookmarked_posts_scope(period)
    return Post.none unless Post.respond_to?(period)
    Post.public_send(period)
      .where.associated(:bookmarks)
      .select(:user_id).distinct
  end
end
account.users.with_bookmarked_posts
User::WithBookmarkedPostsQuery.new(account.users).resolve
# Make sure the class method is no longer defined
User.singleton_class.remove_method :with_bookmarked_posts
class User < ApplicationRecord
  scope :with_bookmarked_posts, WithBookmarkedPostsQuery
end
account.users.with_bookmarked_posts

================
File: Chapter06/03-reusable-scopes-arel.rb
================
require_relative "./prelude"
# Populate data
user = User.create!(name: "Vova")
alice = User.create!(name: "Alice")
post = Post.create!(title: "Query Objects on Rails", tags: ["rails", "active_record"])
post_2 = Post.create!(title: "Reusable Query Objects on Rails with Arel", tags: ["rails", "arel"])
user.bookmarks.create!(post:, tags: %w[ruby todo])
user.bookmarks.create!(post: post_2, tags: %w[unsorted])
alice.bookmarks.create!(post: post_2, tags: %w[ruby sql])
class ApplicationQuery
  class << self
    def query_model
      name.sub(/::[^:]+$/, "").safe_constantize
    end
    def resolve(...) = new.resolve(...)
    alias_method :call, :resolve
  end
  private attr_reader :relation
  def initialize(relation = self.class.query_model.all)
    @relation = relation
  end
  def resolve(...) = relation
end
class Bookmark
  # Add human-readable string representation
  # for demonstration purposes
  def inspect
    "#{user.name} bookmarked post #{post.title} (##{post.id}) with tags: #{tags&.join(", ") || "none"}"
  end
end
class Post < ApplicationRecord
  scope :tagged, ->(tag) {
    where("EXISTS (SELECT 1 FROM json_each(tags) WHERE value = ?)", tag)
  }
end
Post.tagged("rails")
class Bookmark < ApplicationRecord
  scope :tagged, ->(tags) {
    where("EXISTS (SELECT 1 FROM json_each(tags) WHERE value = ?)", tags)
  }
end
user.bookmarks.tagged("ruby")
class TaggedQuery < ApplicationQuery
  def resolve(tag)
    relation.where("EXISTS (" \
      "SELECT 1 FROM json_each(tags) WHERE value = ?" \
    ")", tag)
  end
end
# For posts
TaggedQuery.new(Post.all).resolve("rails")
# For bookmarks
TaggedQuery.new(user.bookmarks).resolve("ruby")
class ApplicationQuery
  class << self
    attr_writer :query_model_name
    def query_model_name
      @query_model_name ||= name.sub(/::[^:]+$/, "")
    end
    def query_model
      query_model_name.safe_constantize
    end
    def [](model)
      Class.new(self).tap { _1.query_model_name = model.name }
    end
  end
end
class Post < ApplicationRecord
  scope :tagged, TaggedQuery[self]
end
class Bookmark < ApplicationRecord
  scope :tagged, TaggedQuery[self]
end
Post.tagged("rails")
user.bookmarks.tagged("ruby")
class User < ApplicationRecord
  has_many :bookmarked_posts, through: :bookmarks, source: :post
end
begin
  user.bookmarked_posts.tagged("rails").pluck(:title)
rescue => e
  puts "#{e.class}: #{e.message}"
end
class TaggedQuery < ApplicationQuery
  def resolve(tag)
    relation.where("EXISTS (" \
      "SELECT 1 FROM
       json_each(#{relation.table_name}.tags)
       WHERE value = ?" \
    ")", tag)
  end
end
puts user.bookmarked_posts.tagged("rails").pluck(:title)
puts user.bookmarked_posts.tagged("arel").pluck(:title)
class TaggedQuery < ApplicationQuery
  def resolve(tag)
    # SELECT 1 FROM json_each(tags) WHERE value in (...)
    tags_subquery = tags_table.project(1).where(tags_table[:value].eq(tag))
    relation.where(tags_subquery.exists)
  end
  private
  def tags_table
    @tags_arel ||= Arel::Nodes::NamedFunction.new("json_each", [arel_table[:tags]]).then do
      name = Arel.sql(_1.to_sql)
      Arel::Table.new(name, as: :json_tags)
    end
  end
  def arel_table = self.class.query_model.arel_table
end
Bookmark.tagged("sql")

================
File: Chapter06/04-repositories.rb
================
require_relative "./prelude"
class Post < ApplicationRecord
  scope :tagged, ->(tag) {
    where("EXISTS (SELECT 1 FROM json_each(tags) WHERE value = ?)", tag)
  }
end
post = Post.create(title: "Active Record vs. Data Mapper", tags: %w[rails orm])
post.update!(draft: false)
Post.all
Post.tagged("rails")
class PostsRepository
  def all = Post.all.to_a
  def find(id) = Post.find_by(id:)
  def add(attrs) = Post.create!(attrs)
  def publish(post) = post.update!(draft: false)
  def search(tag: nil)
    Post.where("EXISTS (SELECT 1 FROM json_each(tags) WHERE value = ?)", tag)
  end
end
repo = PostsRepository.new
post = repo.add(title: "Repositories on Rails", tags: %w[orm data_mapper])
repo.publish(post)
repo.all
repo.search(tag: "orm")
class ApplicationRepository
  class << self
    attr_writer :model_name
    def model_name
      @model_name ||= name.sub(/Repository$/, "").singularize
    end
    def model
      model_name.safe_constantize
    end
  end
  delegate :model, to: :class
  def all = model.all.to_a
  def find(id) = model.find_by(id:)
  def add(attrs) = model.create!(attrs)
end
# Make sure the constant is fresh
Object.send(:remove_const, :PostsRepository) # :ignore:all
class PostsRepository < ApplicationRepository
  def publish(post) = post.update!(draft: false)
  def search(tag: nil)
    model.where("EXISTS (SELECT 1 FROM json_each(tags) WHERE value = ?)", tag)
  end
end
repo = PostsRepository.new
post = repo.add(title: "Repositories on Rails", tags: %w[orm data_mapper])
repo.publish(post)
repo.all
repo.search(tag: "orm")

================
File: Chapter06/prelude.rb
================
# frozen_string_literal: true
require_relative "../lib/helpers"
using ChapterHelpers
schema do
  create_table :accounts, force: true do |t|
    t.string :name
  end
  create_table :users, force: true do |t|
    t.string :name, null: true
    t.belongs_to :account, null: true
  end
  create_table :posts, force: true do |t|
    t.string :title, null: false
    t.boolean :draft, null: false, default: false
    t.datetime :deleted_at, null: true
    t.belongs_to :user
    t.json :tags, null: true
    t.timestamps null: true
  end
  create_table :bookmarks, force: true do |t|
    t.belongs_to :user
    t.belongs_to :post
    t.json :tags, null: true
  end
end
require_relative "../lib/boot"
# Enable logging to see queries
ActiveRecord::Base.logger = ActiveSupport::Logger.new($stdout)
class Account < ApplicationRecord
  has_many :users, dependent: :destroy
end
class User < ApplicationRecord
  belongs_to :account, optional: true
  has_many :posts, dependent: :destroy
  has_many :bookmarks, dependent: :destroy
end
class Post < ApplicationRecord
  belongs_to :user, optional: true
  has_many :bookmarks, dependent: :destroy
end
class Bookmark < ApplicationRecord
  belongs_to :user
  belongs_to :post
end

================
File: Chapter07/views/03/invitations/new.html.erb
================
<div class="mx-auto md:w-2/3 w-full">
  <h1 class="font-bold text-4xl">Invite user</h1>

  <%= form_for(@invitation_form, class: "contents") do |form| %>
    <% if @invitation_form.errors.any? %>
      <div id="error_explanation" class="bg-red-50 text-red-500 px-3 py-2 font-medium rounded-lg mt-3">
        <ul>
          <% @invitation_form.errors.each do |error| %>
            <li><%= error.full_message %></li>
          <% end %>
        </ul>
      </div>
    <% end %>

    <div class="my-5">
      <%= form.label :email %>
      <%= form.text_field :email, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
    </div>

    <div class="my-5 flex flex-column">
      <%= form.label :send_copy, "Send me the copy" %>
      <%= form.check_box :send_copy, class: "block mt-1 h-5 w-5 ml-2" %>
    </div>

    <div class="inline">
      <%= form.submit "Invite", class: "rounded-lg py-3 px-5 bg-blue-600 text-white inline-block font-medium cursor-pointer" %>
    </div>
  <% end %>
</div>

================
File: Chapter07/views/feedbacks/new.html.erb
================
<div class="mx-auto md:w-2/3 w-full">
  <h1 class="font-bold text-4xl">Share your feedback!</h1>

  <%= form_for(@feedback_form, class: "contents") do |form| %>
    <% if @feedback_form.errors.any? %>
      <div id="error_explanation" class="bg-red-50 text-red-500 px-3 py-2 font-medium rounded-lg mt-3">
        <ul>
          <% @feedback_form.errors.each do |error| %>
            <li><%= error.full_message %></li>
          <% end %>
        </ul>
      </div>
    <% end %>

    <div class="my-5">
      <%= form.label :name %>
      <%= form.text_field :name, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
    </div>

    <div class="my-5">
      <%= form.label :email %>
      <%= form.text_field :email, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
    </div>

    <div class="my-5">
      <%= form.label :message %>
      <%= form.text_area :message, rows: 4, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
    </div>

    <div class="inline">
      <%= form.submit "Send", class: "rounded-lg py-3 px-5 bg-blue-600 text-white inline-block font-medium cursor-pointer" %>
    </div>
  <% end %>
</div>

================
File: Chapter07/views/invitations/new.html.erb
================
<div class="mx-auto md:w-2/3 w-full">
  <h1 class="font-bold text-4xl">Invite user</h1>

  <%= form_for(@user, url: invitations_path, class: "contents") do |form| %>
    <% if @user.errors.any? %>
      <div id="error_explanation" class="bg-red-50 text-red-500 px-3 py-2 font-medium rounded-lg mt-3">
        <ul>
          <% @user.errors.each do |error| %>
            <li><%= error.full_message %></li>
          <% end %>
        </ul>
      </div>
    <% end %>

    <div class="my-5">
      <%= form.label :email %>
      <%= form.text_field :email, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
    </div>

    <div class="my-5 flex flex-column">
      <%= label_tag :send_copy, "Send me the copy" %>
      <%= check_box_tag :send_copy, class: "block mt-1 h-5 w-5 ml-2" %>
    </div>

    <div class="inline">
      <%= form.submit "Invite", class: "rounded-lg py-3 px-5 bg-blue-600 text-white inline-block font-medium cursor-pointer" %>
    </div>
  <% end %>
</div>

================
File: Chapter07/views/registrations/new.html.erb
================
<div class="mx-auto md:w-2/3 w-full">
  <h1 class="font-bold text-4xl">Sign up</h1>

  <%= form_for(@user, url: registrations_path, class: "contents") do |form| %>
    <% if @user.errors.any? %>
      <div id="error_explanation" class="bg-red-50 text-red-500 px-3 py-2 font-medium rounded-lg mt-3">
        <ul>
          <% @user.errors.each do |error| %>
            <li><%= error.full_message %></li>
          <% end %>
        </ul>
      </div>
    <% end %>

    <div class="my-5">
      <%= form.label :name %>
      <%= form.text_field :name, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
    </div>

    <div class="my-5">
      <%= form.label :email %>
      <%= form.text_field :email, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
    </div>

    <div class="inline">
      <%= form.submit "Sign me up", class: "rounded-lg py-3 px-5 bg-blue-600 text-white inline-block font-medium cursor-pointer" %>
    </div>
  <% end %>
</div>

================
File: Chapter07/views/users/_form.html.erb
================
<%= form_with(model: user, class: "contents") do |form| %>
  <% if user.errors.any? %>
    <div id="error_explanation" class="bg-red-50 text-red-500 px-3 py-2 font-medium rounded-lg mt-3">
      <h2><%= pluralize(user.errors.count, "error") %> prohibited this user from being saved:</h2>

      <ul>
        <% user.errors.each do |error| %>
          <li><%= error.full_message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div class="my-5">
    <%= form.label :name %>
    <%= form.text_field :name, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
  </div>

  <div class="my-5">
    <%= form.label :email %>
    <%= form.text_field :email, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
  </div>

  <div class="inline">
    <%= form.submit class: "rounded-lg py-3 px-5 bg-blue-600 text-white inline-block font-medium cursor-pointer" %>
  </div>
<% end %>

================
File: Chapter07/views/users/_user.html.erb
================
<div id="<%= dom_id user %>">
  <p class="my-5">
    <strong class="block font-medium mb-1">Name:</strong>
    <%= user.name %>
  </p>

  <p class="my-5">
    <strong class="block font-medium mb-1">Email:</strong>
    <%= user.email %>
  </p>

  <% if action_name != "show" %>
    <%= link_to "Show this user", user, class: "rounded-lg py-3 px-5 bg-gray-100 inline-block font-medium" %>
    <%= link_to 'Edit this user', edit_user_path(user), class: "rounded-lg py-3 ml-2 px-5 bg-gray-100 inline-block font-medium" %>
    <hr class="mt-6">
  <% end %>
</div>

================
File: Chapter07/views/users/edit.html.erb
================
<div class="mx-auto md:w-2/3 w-full">
  <h1 class="font-bold text-4xl">Editing user</h1>

  <%= render "form", user: @user %>

  <%= link_to "Show this user", @user, class: "ml-2 rounded-lg py-3 px-5 bg-gray-100 inline-block font-medium" %>
  <%= link_to "Back to users", users_path, class: "ml-2 rounded-lg py-3 px-5 bg-gray-100 inline-block font-medium" %>
</div>

================
File: Chapter07/views/users/index.html.erb
================
<div class="w-full">
  <% if notice.present? %>
    <p class="py-2 px-3 bg-green-50 mb-5 text-green-500 font-medium rounded-lg inline-block" id="notice"><%= notice %></p>
  <% end %>

  <div class="flex justify-between items-center">
    <h1 class="font-bold text-4xl">Users</h1>
    <%= link_to 'New user', new_user_path, class: "rounded-lg py-3 px-5 bg-blue-600 text-white block font-medium" %>
  </div>

  <div id="users" class="min-w-full">
    <%= render @users %>
  </div>
</div>

================
File: Chapter07/views/users/new.html.erb
================
<div class="mx-auto md:w-2/3 w-full">
  <h1 class="font-bold text-4xl">New user</h1>

  <%= render "form", user: @user %>

  <%= link_to 'Back to users', users_path, class: "ml-2 rounded-lg py-3 px-5 bg-gray-100 inline-block font-medium" %>
</div>

================
File: Chapter07/views/users/show.html.erb
================
<div class="mx-auto md:w-2/3 w-full flex">
  <div class="mx-auto">
    <% if notice.present? %>
      <p class="py-2 px-3 bg-green-50 mb-5 text-green-500 font-medium rounded-lg inline-block" id="notice"><%= notice %></p>
    <% end %>

    <%= render @user %>

    <%= link_to 'Edit this user', edit_user_path(@user), class: "mt-2 rounded-lg py-3 px-5 bg-gray-100 inline-block font-medium" %>
    <div class="inline-block ml-2">
      <%= button_to 'Destroy this user', user_path(@user), method: :delete, class: "mt-2 rounded-lg py-3 px-5 bg-gray-100 font-medium" %>
    </div>
    <%= link_to 'Back to users', users_path, class: "ml-2 rounded-lg py-3 px-5 bg-gray-100 inline-block font-medium" %>
  </div>
</div>

================
File: Chapter07/00-scaffold-controller.rb
================
require_relative "./prelude"
using ChapterHelpers
# This code was generated by Rails, ignore it
# rubocop:disable all
class UsersController < ApplicationController
  before_action :set_user, only: %i[ show edit update destroy ]
  # GET /users
  def index
    @users = User.all
  end
  # GET /users/1
  def show
  end
  # GET /users/new
  def new
    @user = User.new
  end
  # GET /users/1/edit
  def edit
  end
  # POST /users
  def create
    @user = User.new(user_params)
    if @user.save
      redirect_to @user, notice: "User was successfully created."
    else
      render :new, status: :unprocessable_entity
    end
  end
  # PATCH/PUT /users/1
  def update
    if @user.update(user_params)
      redirect_to @user, notice: "User was successfully updated."
    else
      render :edit, status: :unprocessable_entity
    end
  end
  # DELETE /users/1
  def destroy
    @user.destroy!
    redirect_to users_url, notice: "User was successfully destroyed.", status: :see_other
  end
  private
    # Use callbacks to share common setup or constraints between actions.
    def set_user
      @user = User.find(params[:id])
    end
    # Only allow a list of trusted parameters through.
    def user_params
      params.require(:user).permit(:name, :email)
    end
end
response = get "/users/new"
puts response.body

================
File: Chapter07/01-invitations-registrations-controllers.rb
================
require_relative "./prelude"
using ChapterHelpers
class InvitationsController < ApplicationController
  def new
    @user = User.new
  end
  def create
    @user = User.new(params.require(:user).permit(:email))
    if @user.save
      redirect_to root_path
    else
      render :new, status: :unprocessable_entity
    end
  end
end
class RegistrationsController < ApplicationController
  def new
    @user = User.new
  end
  def create
    @user = User.new(params.require(:user).permit(:email, :name))
    @user.confirmed_at = Time.current
    if @user.save
      redirect_to root_path
    else
      render :new, status: :unprocessable_entity
    end
  end
end
class User < ApplicationRecord
  validates :email, presence: true, uniqueness: true
  validates :name, presence: true, if: :confirmed?
  def confirmed? = confirmed_at.present?
end
response = get "/invitations/new"
puts response.body
post "/invitations", params: {user: {email: "palkan@evl.ms"}}
invited_user = User.find_by!(email: "palkan@evl.ms")
invited_user.confirmed?
response = get "/registrations/new"
puts response.body
post "/registrations", params: {user: {name: "Vova", email: "palkan@evilmartians.com"}}
response.status
registered_user = User.find_by!(email: "palkan@evilmartians.com")
registered_user.confirmed?
# Adding notifications
class User < ApplicationRecord
  after_create_commit :send_invitation, unless: :confirmed?
  after_create_commit :send_welcome_email, if: :confirmed?
  def send_invitation
    UserMailer.invite(self).deliver_later
  end
  def send_welcome_email
    UserMailer.welcome(self).deliver_later
  end
end
post "/invitations", params: {user: {email: "palkan+notify@evl.ms"}}
post "/registrations", params: {user: {name: "Vova 2", email: "palkan+notify@evilmartians.com"}}
# Add virtual attributes to control notifications
class User < ApplicationRecord
  attribute :should_send_invitation, :boolean
  attribute :should_send_welcome_email, :boolean
  after_create_commit :send_invitation, if: :should_send_invitation
  after_create_commit :send_welcome_email, if: :should_send_welcome_email
end
class InvitationsController < ApplicationController
  def create
    @user = User.new(params.require(:user).permit(:email))
    @user.should_send_invitation = true
    if @user.save
      redirect_to root_path
    else
      render :new, status: :unprocessable_entity
    end
  end
end
class RegistrationsController < ApplicationController
  def create
    @user = User.new(params.require(:user).permit(:email, :name))
    @user.confirmed_at = Time.current
    @user.should_send_welcome_email = true
    if @user.save
      redirect_to root_path
    else
      render :new, status: :unprocessable_entity
    end
  end
end
post "/invitations", params: {user: {email: "palkan+notify+attributes@evl.ms"}}
post "/registrations", params: {user: {name: "Still Vova", email: "palkan+notify+attributes@evilmartians.com"}}
# Send a copy of invitation to the current user
current_user = User.create!(email: "admin@local.test", name: "Admin")
class InvitationsController < ApplicationController
  def create
    @user = User.new(params.require(:user).permit(:email))
    @user.should_send_invitation = true
    if @user.save
      if params[:send_copy] == "1"
        UserMailer.invite_copy(current_user, @user)
          .deliver_later
      end
      redirect_to root_path
    else
      render :new, status: :unprocessable_entity
    end
  end
end
post "/invitations", params: {user: {email: "palkan+notify+copy@evl.ms"}, send_copy: "1"}, cookies: {user_id: current_user.id}

================
File: Chapter07/02-invitation-form.rb
================
require_relative "./prelude"
using ChapterHelpers
class UserInvitationForm
  attr_reader :user, :send_copy, :sender
  def initialize(params, send_copy: false, sender: nil)
    @user = User.new(params)
    @send_copy = send_copy.in?(%w[1 t true])
    @sender = sender
  end
  def save
    validate!
    return false if user.errors.any?
    user.save!
    deliver_notifications!
  end
  private
  def validate!
    user.errors.add(:email, :blank) if user.email.blank?
  end
  def deliver_notifications!
    UserMailer.invite(user).deliver_later
    if send_copy
      UserMailer.invite_copy(sender, user).deliver_later
    end
  end
end
class InvitationsController < ApplicationController # :ignore:
  def new
    @user = User.new
  end
  def create
    form = UserInvitationForm.new(
      params.require(:user).permit(:email).to_h,
      send_copy: params[:send_copy],
      sender: current_user
    )
    if form.save
      redirect_to root_path
    else
      @user = form.user
      render :new, status: :unprocessable_entity
    end
  end
end
current_user = User.create!(email: "admin@local.test", name: "Admin")
post "/invitations", params: {user: {email: "palkan@evl.ms"}, send_copy: "1"}, cookies: {user_id: current_user.id}
User.find_by!(email: "palkan@evl.ms")
response = post "/invitations", params: {user: {email: ""}, send_copy: "1"}, cookies: {user_id: current_user.id}
puts response.body

================
File: Chapter07/03-invitation-active-model-form.rb
================
require_relative "./prelude"
using ChapterHelpers
class ApplicationForm
  include ActiveModel::API
  include ActiveModel::Attributes
  define_callbacks :save, only: :after
  define_callbacks :commit, only: :after
  class << self
    def after_save(...)
      set_callback(:save, :after, ...)
    end
    def after_commit(...)
      set_callback(:commit, :after, ...)
    end
  end
  def save
    return false unless valid?
    with_transaction do
      AfterCommitEverywhere.after_commit { run_callbacks(:commit) }
      run_callbacks(:save) { submit! }
    end
  end
  private
  def with_transaction(&) = ApplicationRecord.transaction(&)
  def submit!
    raise NotImplementedError
  end
end
class InvitationForm < ApplicationForm
  attribute :email
  attribute :send_copy, :boolean
  attr_accessor :sender
  validates :email, presence: true
  after_commit :deliver_invitation
  after_commit :deliver_invitation_copy, if: :send_copy
  private
  attr_reader :user
  def submit!
    @user = User.new(email:)
    user.save!
  end
  def deliver_invitation
    UserMailer.invite(user).deliver_later
  end
  def deliver_invitation_copy
    UserMailer.invite_copy(sender, user).deliver_later if sender
  end
end
class InvitationsController < ApplicationController
  def new
    @invitation_form = InvitationForm.new
  end
  def create
    @invitation_form = InvitationForm.new(
      params.require(:invitation).permit(:email, :send_copy)
    )
    @invitation_form.sender = current_user
    if @invitation_form.save
      redirect_to root_path
    else
      render :new, status: :unprocessable_entity
    end
  end
end
current_user = User.create!(email: "admin@local.test", name: "Admin")
post "/invitations", params: {invitation: {email: "palkan@evl.ms", send_copy: "1"}}, cookies: {user_id: current_user.id}
User.find_by!(email: "palkan@evl.ms")
# Making friends with Action View
class ApplicationForm
  def model_name
    ActiveModel::Name.new(nil, nil, self.class.name.sub(/Form$/, ""))
  end
end
response = get "/invitations/new"
puts response.body
# Making friends with strong parameters
class ApplicationForm
  class << self
    def from(params)
      new(params.permit(attribute_names.map(&:to_sym)))
    end
  end
end
class InvitationsController < ApplicationController
  def create
    @invitation_form = InvitationForm.from(params.require(:invitation))
    @invitation_form.sender = current_user
    if @invitation_form.save
      redirect_to root_path
    else
      render :new, status: :unprocessable_entity
    end
  end
end
post "/invitations", params: {invitation: {email: "palkan+2@evl.ms"}}, cookies: {user_id: current_user.id}
User.find_by!(email: "palkan+2@evl.ms")

================
File: Chapter07/04-multi-model-form.rb
================
require_relative "./prelude"
using ChapterHelpers
class ApplicationForm
  include ActiveModel::API
  include ActiveModel::Attributes
  define_callbacks :save, only: :after
  define_callbacks :commit, only: :after
  class << self
    def after_save(...)
      set_callback(:save, :after, ...)
    end
    def after_commit(...)
      set_callback(:commit, :after, ...)
    end
  end
  def save
    return false unless valid?
    with_transaction do
      AfterCommitEverywhere.after_commit { run_callbacks(:commit) }
      run_callbacks(:save) { submit! }
    end
  end
  private
  def with_transaction(&) = ApplicationRecord.transaction(&)
  def submit!
    raise NotImplementedError
  end
end
class User < ApplicationRecord
  validates :email, :name, presence: true
end
class RegistrationForm < ApplicationForm
  attribute :name
  attribute :email
  attribute :should_create_project, :boolean
  attribute :project_name
  validates :project_name, presence: true, if: :should_create_project
  attr_reader :user
  after_save :create_initial_project, if: :should_create_project
  private
  def submit!
    @user = User.create!(email:, name:)
  end
  def create_initial_project
    user.projects.create!(name: project_name)
  end
end
form = RegistrationForm.new(
  {name: "Vova", email: "vova@rails.test", project_name: "Rails Cake", should_create_project: "t"}
)
form.save
puts Project.find_by(name: "Rails Cake").user.name
begin
  RegistrationForm.new(name: "Test").save
rescue ActiveRecord::RecordInvalid => e
  puts "#{e.class}: #{e.message}"
end
# Errors delegation
class ApplicationForm
  def merge_errors!(other)
    other.errors.each do |e|
      errors.add(e.attribute, e.type, message: e.message)
    end
  end
end
class RegistrationForm < ApplicationForm
  validate :user_is_valid
  def initialize(...)
    super
    @user = User.new(email:, name:)
  end
  private
  def submit!
    user.save!
  end
  def user_is_valid
    return if user.valid?
    merge_errors!(user)
  end
end
form = RegistrationForm.new(name: "Test")
form.save
puts form.errors.full_messages

================
File: Chapter07/05-model-less-form.rb
================
require_relative "./prelude"
using ChapterHelpers
class ApplicationForm
  include ActiveModel::API
  include ActiveModel::Attributes
  define_callbacks :save, only: :after
  define_callbacks :commit, only: :after
  class << self
    def after_save(...)
      set_callback(:save, :after, ...)
    end
    def after_commit(...)
      set_callback(:commit, :after, ...)
    end
    def from(params)
      new(params.permit(attribute_names.map(&:to_sym)))
    end
  end
  def save
    return false unless valid?
    with_transaction do
      AfterCommitEverywhere.after_commit { run_callbacks(:commit) }
      run_callbacks(:save) { submit! }
    end
  end
  def model_name
    ActiveModel::Name.new(nil, nil, self.class.name.sub(/Form$/, ""))
  end
  private
  def with_transaction(&) = ApplicationRecord.transaction(&)
  def submit!
    raise NotImplementedError
  end
end
class FeedbackForm < ApplicationForm
  attribute :name
  attribute :email
  attribute :message
  validates :name, :email, :message, presence: true
  validates :message, length: {maximum: 160}
  after_commit do
    SystemMailer.feedback(email, name, message).deliver_later
  end
  def submit! = true
end
form = FeedbackForm.new(
  name: "Alice",
  email: "alice@example.com",
  message: "Help, I need somebody, not just anybody"
)
form.save
class FeedbacksController < ApplicationController
  def new
    @feedback_form = FeedbackForm.new
  end
  def create
    @feedback_form = FeedbackForm.from(params.require(:feedback))
    if @feedback_form.save
      redirect_to root_path
    else
      render :new, status: :unprocessable_entity
    end
  end
end

================
File: Chapter07/06-filtering-controller.rb
================
require_relative "./prelude"
using ChapterHelpers
class ProjectsController < ApplicationController
  def index
    projects = Project.all.order(sort_params)
    if params[:type_filter].in?(%w[published draft])
      projects.where!(
        status: params[:type_filter]
      )
    end
    if params[:time_filter] == "future"
      projects.where!(started_at: Time.current...)
    end
    if params[:q].present?
      projects.where!(Project[:name].matches("%#{params[:q]}%"))
    end
    render json: projects
  end
  def sort_params
    col, ord = params.values_at(:sort_by, :sort_order)
    col = :started_at unless col.in?(%w[id name started_at])
    ord = :desc unless ord.in?(%w[asc desc])
    {col => ord}
  end
end
require_relative "projects_controller_spec"
RSpec::Core::Runner.run([])

================
File: Chapter07/07-filtering-model-scopes.rb
================
require_relative "./prelude"
using ChapterHelpers
class Project < ApplicationRecord
  scope :filter_by_type, -> {
    where(status: _1) if _1.in?(%w[published draft])
  }
  scope :filter_by_time, -> {
    where(started_at: Time.current...) if _1 == "future"
  }
  scope :searched, -> {
    where(arel_table[:name].matches("%#{_1}%")) if
      _1.present?
  }
  scope :sorted, (lambda do |col, ord|
    col = :started_at unless
      col.in?(%w[id name started_at])
    ord = :desc unless ord.in?(%w[asc desc])
    order(col => ord)
  end)
end
class ProjectsController < ApplicationController
  def index
    projects = Project.all
      .filter_by_type(params[:type_filter])
      .filter_by_time(params[:time_filter])
      .searched(params[:q])
      .sorted(params[:sort_by], params[:sort_order])
    render json: projects
  end
end
require_relative "projects_controller_spec"
RSpec::Core::Runner.run([])

================
File: Chapter07/08-filter-object.rb
================
require_relative "./prelude"
using ChapterHelpers
class Project < ApplicationRecord
  scope :future, -> { where(started_at: Time.current...) }
end
class ApplicationFilter < Rubanok::Processor
  class << self
    alias filter call
  end
end
class ProjectsFilter < ApplicationFilter
  TYPES = %w[draft published].freeze
  SORT_FIELDS = %w[id name started_at].freeze
  SORT_ORDERS = %w[asc desc].freeze
  map :type_filter do |type_filter:|
    next raw.none unless TYPES.include?(type_filter)
    raw.where(status: type_filter)
  end
  match :time_filter do
    having "future" do
      raw.future
    end
  end
  map :sort_by, :sort_order, activate_always: true do |sort_by: "started_at", sort_order: "desc"|
    next raw unless SORT_FIELDS.include?(sort_by) &&
      SORT_ORDERS.include?(sort_order)
    raw.order(sort_by => sort_order)
  end
  map :q do |q:|
    raw.where(Project[:name].matches("%#{q}%"))
  end
end
class ProjectsController < ApplicationController
  def index
    projects = ProjectsFilter.filter(Project.all, params)
    render json: projects
  end
end
require_relative "rails_helper"
RSpec.describe ProjectsController, type: :request do
  before do
    allow(ProjectsFilter)
      .to receive(:filter).and_call_original
  end
  it "uses ProjectsFilter" do
    get "/projects.json"
    expect(response.status).to eq(200)
    expect(ProjectsFilter).to have_received(:filter)
      .with(Project.all,
        an_instance_of(ActionController::Parameters))
  end
end
require_relative "projects_controller_spec"
RSpec::Core::Runner.run([])

================
File: Chapter07/09-application-record-filter.rb
================
require_relative "./prelude"
using ChapterHelpers
class ApplicationRecord < ActiveRecord::Base
  def self.filter_by(params, with: nil)
    filter_class = with || "#{name.pluralize}Filter".constantize
    filter_class.filter(self, params)
  end
end
class ApplicationFilter < Rubanok::Processor
  class << self
    alias filter call
  end
end
class ProjectsFilter < ApplicationFilter
  # ...
  map :q do |q:|
    raw.where(Project[:name].matches("%#{q}%"))
  end
end
Project.insert_all([
  {
    name: "Layering Rails book",
    started_at: Time.zone.parse("2022-07-01 9:00:00"),
    status: "draft"
  },
  {
    name: "Real-time Rails book",
    started_at: 1.year.since,
    status: "draft"
  },
  {
    name: "AnyCable",
    started_at: Time.zone.parse("2016-07-15 11:04:00"),
    status: "published"
  }
])
puts Project.filter_by({q: "Any"}).pluck(:name)
puts Project.where(started_at: ...Time.current).filter_by({q: "Rails"}).pluck(:name)

================
File: Chapter07/prelude.rb
================
# frozen_string_literal: true
require_relative "../lib/helpers"
using ChapterHelpers
gems do
  # For base form object
  gem "after_commit_everywhere", "~> 1.3.0"
  # For shorter Arel syntax in filters
  gem "arel-helpers", "~> 2.14.0"
  # For filter objects
  gem "rubanok", "~> 0.4.0"
  # For filtering specs
  gem "rspec-rails", "6.1.0"
end
schema do
  create_table :users, force: true do |t|
    t.string :name, null: true
    t.string :email, null: true, index: {unique: true}
    t.datetime :confirmed_at
    t.timestamps
  end
  create_table :projects, force: true do |t|
    t.string :name, null: true
    t.belongs_to :user, null: true
    t.datetime :started_at
    t.string :status, null: false, default: "draft"
    t.timestamps
  end
end
routes do
  resources :users
  resources :invitations, only: [:new, :create]
  resources :registrations, only: [:new, :create]
  resources :feedbacks, only: [:new, :create]
  resources :projects, only: [:index]
end
require_relative "../lib/boot"
class User < ApplicationRecord
  has_many :projects
end
class Project < ApplicationRecord
  include ArelHelpers::ArelTable
  belongs_to :user
  def as_json(*)
    {
      id:,
      name:,
      status:,
      started_at:
    }
  end
end
class UserMailer < ApplicationMailer
  def invite(user)
    mail(
      to: user.email,
      subject: "You've been invited!",
      body: "Hello, friend! You've been invited to learn some Ruby on Rails"
    )
  end
  def invite_copy(sender, user)
    mail(
      to: sender.email,
      subject: "Invitation copy",
      body: "You've just invited #{user.email}. Here is the invitation:\nHello, friend! You've been invited to learn some Ruby on Rails"
    )
  end
  def welcome(user)
    mail(
      to: user.email,
      subject: "Welcome!",
      body: "Welcome, #{user.name}!"
    )
  end
end
class SystemMailer < ApplicationMailer
  def feedback(from_email, from_name, message)
    mail(
      to: "support@rails-cake.test",
      reply_to: from_email,
      subject: "New feedback from #{from_name}",
      body: message
    )
  end
end

================
File: Chapter07/projects_controller_spec.rb
================
require_relative "rails_helper"
RSpec.describe ProjectsController, type: :request do
  before do
    # Make sure the database is clean
    Project.delete_all
    Project.insert_all([
      {
        name: "Layering Rails book",
        started_at: Time.zone.parse("2022-07-01 9:00:00"),
        status: "draft"
      },
      {
        name: "Real-time Rails book",
        started_at: 1.year.since,
        status: "draft"
      },
      {
        name: "AnyCable",
        started_at: Time.zone.parse("2016-07-15 11:04:00"),
        status: "published"
      }
    ])
  end
  let(:params) { {} }
  subject(:data) do
    get("/projects", params:)
    JSON.parse(response.body, symbolize_names: true)
  end
  specify do
    expect(data.size).to eq 3
    expect(data.map { _1[:name] }).to eq(%w[
      Real-time\ Rails\ book
      Layering\ Rails\ book
      AnyCable
    ])
  end
  specify "?sort_by=name&sort_order=asc" do
    params[:sort_by] = "name"
    params[:sort_order] = "asc"
    expect(data.size).to eq 3
    expect(data.map { _1[:name] }).to eq(%w[
      AnyCable
      Layering\ Rails\ book
      Real-time\ Rails\ book
    ])
  end
  specify "?sort_by=id" do
    params[:sort_by] = "id"
    expect(data.size).to eq 3
    expect(data.map { _1[:name] }).to eq(%w[
      AnyCable
      Real-time\ Rails\ book
      Layering\ Rails\ book
    ])
  end
  specify "?type_filter=published" do
    params[:type_filter] = "published"
    expect(data.size).to eq 1
    expect(data.map { _1[:name] }).to eq(%w[
      AnyCable
    ])
  end
  specify "?type_filter=unknown" do
    params[:type_filter] = "unknown"
    # Rubanok is stricter about unknown values
    if defined?(ProjectsFilter)
      expect(data.size).to eq 0
    else
      expect(data.size).to eq 3
    end
  end
  specify "?time_filter=future" do
    params[:time_filter] = "future"
    expect(data.size).to eq 1
    expect(data.map { _1[:name] }).to eq(%w[
      Real-time\ Rails\ book
    ])
  end
  specify "?q=Rails" do
    params[:q] = "Rails"
    expect(data.size).to eq 2
    expect(data.map { _1[:name] }).to eq(%w[
      Real-time\ Rails\ book
      Layering\ Rails\ book
    ])
  end
end

================
File: Chapter07/rails_helper.rb
================
# frozen_string_literal: true
require "rspec/rails"
RSpec.configure do |config|
  config.use_transactional_fixtures = true
end

================
File: Chapter08/views/00/posts/_post.html.erb
================
<div>
  <i class="fa <%= post.status_icon %>"></i>
  <span><%= post.title %><span>
  <span> (by <%= post.author_name %>)</span>
</div>

================
File: Chapter08/views/00/posts/index.html.erb
================
<div class="mx-auto md:w-2/3 w-full">
  <h1 class="font-bold text-4xl">Posts</h1>
  <div class="flex flex-col">
    <%= render @posts %>
  </div>
</div>

================
File: Chapter08/views/01/posts/_post.html.erb
================
<div>
  <i class="fa <%= post_icon(post) %>"></i>
  <span><%= post.title %><span>
  <span> (by <%= post_author(post) %>)</span>
</div>

================
File: Chapter08/views/01/posts/index.html.erb
================
<div class="mx-auto md:w-2/3 w-full">
  <h1 class="font-bold text-4xl">Posts</h1>
  <div class="flex flex-col">
    <%= render @posts %>
  </div>
</div>

================
File: Chapter08/views/05/posts/_post.html.erb
================
<div>
  <i class="fa <%= k(post).status_icon %>"></i>
  <span><%= post.title %><span>
  <span> (by <%= k(post.user).short_name %>)</span>
</div>

================
File: Chapter08/views/05/posts/index.html.erb
================
<div class="mx-auto md:w-2/3 w-full">
  <h1 class="font-bold text-4xl">Posts</h1>
  <div class="flex flex-col">
    <%= render @posts %>
  </div>
</div>

================
File: Chapter08/views/books/index.html.erb
================
<%- user = User.first %>

<div class="flex flex-col w-1/3">
  <%- user.book_reads.preload(:book).each do |book_read| -%>
    <%- book = User::BookPresenter.new(book_read.book, book_read) -%>
    <div id="book-<%= book.id %>" class="mt-2 border-b-grey border-b pb-2">
      <h1 class="text-xl">
        <%= link_to book.title, book, class: "text-blue-500 cursor-pointer hover:text-black" %>
        <i class="fa <%= book.progress_icon %> text-blue-300"></i>
      </h1>
      <%- if book.read? %>
        <div class="text-sm text-gray-500 flex justify-between">
            <span>Read on <%= l(book.read_at.to_date, format: :long) %></span>
            <span class="<%= book.score_class %> font-bold">
              <%= number_to_human(book.score) %> / 5
            </span>
        </div>
      <% end %>
    </div>
  <% end %>
</div>

================
File: Chapter08/views/posts/show.html.erb
================
<div>
  Post: <%= @post.title %>
</div>

================
File: Chapter08/00-model-view-methods.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  def short_name
    name.squish.split(/\s/).then do |parts|
      parts[0..-2].map { _1[0] + "." }.join + parts.last
    end
  end
end
ruby = User.create!(name: "Ruby Crystal")
david = User.create!(name: "David Heinemeier Hansson")
class Post < ApplicationRecord
  def status_icon
    "fa-#{draft? ? "hourglass-start" : "calendar-check"}"
  end
  def author_name = user&.short_name
end
crystal_post = Post.create!(title: "Crystal for Rubyists", user: ruby)
rails_post = Post.create!(title: "Rails is the way", draft: false, user: david)
puts crystal_post.status_icon
puts rails_post.author_name
response = get "/posts"
puts response.body

================
File: Chapter08/01-view-helpers.rb
================
require_relative "./prelude"
using ChapterHelpers
ruby = User.create!(name: "Ruby Crystal")
david = User.create!(name: "David Heinemeier Hansson")
crystal_post = Post.create!(title: "Crystal for Rubyists", user: ruby)
rails_post = Post.create!(title: "Rails is the way", draft: false, user: david)
module UsersHelper
  def user_short_name(user)
    user.name.squish.split(/\s/).then do |parts|
      parts[0..-2].map { _1[0] + "." }.join + parts.last
    end
  end
end
module PostsHelper
  def post_icon(post)
    if post.draft?
      "fa-hourglass-start"
    else
      "calendar-check"
    end
  end
  def post_author(post) = user_short_name(post.user)
end
# Register heleprs manually (Rails loads them from app/helpers) # :ignore:
ApplicationController.helper UsersHelper
ApplicationController.helper PostsHelper
response = get "/posts"
puts response.body

================
File: Chapter08/02-poro-presenters.rb
================
require_relative "./prelude"
using ChapterHelpers
user = User.create!(name: "Ruby Crystal")
class UserPresenter
  private attr_reader :user
  def initialize(user) = @user = user
  def short_name
    user.name.squish.split(/\s/).then do |parts|
      parts[0..-2].map { _1[0] + "." }.join + parts.last
    end
  end
end
binding.render <<~ERB
  <div id="user-<%= user.id %>">
    <%= link_to UserPresenter.new(user).short_name, user %>
  </div>
ERB
# Adding delegation
class UserPresenter
  delegate :id, :to_model, to: :user
end
binding.render <<~ERB
  <%- user = UserPresenter.new(user) -%>
  <div id="user-<%= user.id %>">
    <%= link_to user.short_name, user %>
  </div>
ERB

================
File: Chapter08/03-simple-delegator-decorators.rb
================
require_relative "./prelude"
using ChapterHelpers
user = User.create!(name: "Ruby Crystal")
class UserPresenter < SimpleDelegator
  def short_name
    name.squish.split(/\s/).then do |parts|
      parts[0..-2].map { _1[0] + "." }.join + parts.last
    end
  end
end
binding.render <<~ERB
  <%- user = UserPresenter.new(user) -%>
  <div id="user-<%= user.id %>">
    <%= link_to user.short_name, user %>
  </div>
ERB

================
File: Chapter08/04-multi-presenter.rb
================
require_relative "./prelude"
using ChapterHelpers
user = User.create!(name: "Vova Dem")
rails_book = Book.create!(title: "The Rails 4 Way")
ruby_book = Book.create!(title: "Polished Ruby programming")
layers_book = Book.create!(title: "Layering Rails")
user.book_reads.create!(book: rails_book, read_at: 7.years.ago, score: 4)
user.book_reads.create!(book: ruby_book, read_at: 42.days.ago, score: 4.5)
user.book_reads.create!(book: Book.create!(title: "The gardener is not the murderer"), read_at: 100.days.ago, score: 3.5)
user.book_reads.create!(book: layers_book, read_at: nil, score: nil)
class BooksController < ApplicationController # :ignore:
  def index
  end
end
class BookPresenter < SimpleDelegator
end
class User::BookPresenter < BookPresenter
  private attr_reader :book_read
  delegate :read?, :read_at, :score, to: :book_read
  def initialize(book, book_read)
    super(book)
    @book_read = book_read
  end
  def progress_icon
    read? ? "fa-circle-check" : "fa-clock"
  end
  def score_class
    case score
    when 0..2 then "text-red-600"
    when 3...4 then "text-yellow-600"
    when 4... then "text-green-600"
    end
  end
end
binding.render <<~ERB
  <%- user.book_reads.preload(:book).each do |book_read| -%>
    <%- book = User::BookPresenter.new(book_read.book, book_read) -%>
    <div id="book-<%= book.id %>">
      <h1>
         <%= book.title %>
         <i class="fa <%= book.progress_icon %>"></i>
       </h1>
       <%- if book.read? %>
         <div>
            <span>Read on <%= l(book.read_at) %></span>
            <span class="<%= book.score_class %>">
              <%= book.score %> / 5
            </span>
         </div>
       <% end %>
    </div>
  <% end %>
ERB

================
File: Chapter08/05-keynote-presenter.rb
================
require_relative "./prelude"
using ChapterHelpers
ruby = User.create!(name: "Ruby Crystal")
david = User.create!(name: "David Heinemeier Hansson")
crystal_post = Post.create!(title: "Crystal for Rubyists", user: ruby)
rails_post = Post.create!(title: "Rails is the way", draft: false, user: david)
class UserPresenter < Keynote::Presenter
  presents :user
  def short_name
    user.name.squish.split(/\s/).then do |parts|
      parts[0..-2].map { _1[0] + "." }.join + parts.last
    end
  end
end
class PostPresenter < Keynote::Presenter
  presents :post
  def status_icon
    if post.draft?
      "fa-hourglass-start"
    else
      "fa-calendar-check"
    end
  end
end
response = get "/posts"
puts response.body

================
File: Chapter08/06-keynote-presenter-view-helpers.rb
================
require_relative "./prelude"
using ChapterHelpers
ruby = User.create!(name: "Ruby Crystal")
david = User.create!(name: "David Heinemeier Hansson")
crystal_post = Post.create!(title: "Crystal for Rubyists", user: ruby)
rails_post = Post.create!(title: "Rails is the way", draft: false, user: david)
class UserPresenter < Keynote::Presenter
  presents :user
  def short_name
    user.name.squish.split(/\s/).then do |parts|
      parts[0..-2].map { _1[0] + "." }.join + parts.last
    end
  end
end
class PostPresenter < Keynote::Presenter
  presents :post
  def status_icon
    icon = post.draft? ? "hourglass-start" : "clock"
    content_tag(:i, nil, class: "fa fa-#{icon}")
  end
end
post = crystal_post
binding.render <<~ERB
  <div>
    <%= k(post).status_icon %>
    <span><%= post.title %><span>
  </div>
ERB

================
File: Chapter08/07-leaking-decorator.rb
================
require_relative "./prelude"
using ChapterHelpers
ruby = User.create!(name: "Ruby Crystal")
crystal_post = Post.create!(title: "Crystal for Rubyists", user: ruby)
class PostPresenter < SimpleDelegator
end
class ApplicationController
  def present(obj, with: nil)
    presenter_class = with ||
      "#{obj.class.name}Presenter".constantize
    presenter_class.new(obj)
  end
end
module Analytics
  def self.track_event(name, obj)
    puts "event=#{name} id=#{obj.id} class=#{obj.class}"
  end
end
class PostsController < ApplicationController
  before_action :set_post, only: [:show]
  def show
    Analytics.track_event("post.viewed", @post)
  end
  private
  def set_post = @post = present(Post.find(params[:id]))
end
get "/posts/#{crystal_post.id}"

================
File: Chapter08/08-render-json.rb
================
require_relative "./prelude"
using ChapterHelpers
user = User.create!(name: "J Son")
post = Post.create!(title: "Serialize all the things", user:)
class PostsController < ApplicationController
  def show
    post = Post.find(params[:id])
    render json: post
  end
end
response = get "/posts/#{post.id}"
puts response.body
class Post < ApplicationRecord
  belongs_to :user
  def as_json(options)
    super({
      only: [:id, :title, :draft],
      include: {user: {only: [:id, :name]}}
    }.merge(options))
  end
end
response = get "/posts/#{post.id}"
puts response.body
class PostsController < ApplicationController
  def show
    post = Post.find(params[:id])
    render json: post.as_json({only: [:id]})
  end
end
response = get "/posts/#{post.id}"
puts response.body

================
File: Chapter08/09-poro-serializers.rb
================
require_relative "./prelude"
using ChapterHelpers
ruby = User.create!(name: "Ruby Crystal")
david = User.create!(name: "David Heinemeier Hansson")
crystal_post = Post.create!(title: "Crystal for Rubyists", user: ruby)
rails_post = Post.create!(title: "Rails is the way", draft: false, user: david)
class UserPresenter < SimpleDelegator
  def short_name
    name.squish.split(/\s/).then do |parts|
      parts[0..-2].map { _1[0] + "." }.join + parts.last
    end
  end
  def as_json(...)
    {id:, short_name:}
  end
end
class PostPresenter < SimpleDelegator
  def as_json(...)
    {
      id:, title:,
      is_draft: draft?,
      user: UserPresenter.new(user)
    }
  end
end
class PostsController < ApplicationController
  def index
    render json: Post.all.map { PostPresenter.new(_1) }
  end
end
response = get "/posts"
puts response.body

================
File: Chapter08/10-alba-serializers.rb
================
require_relative "./prelude"
using ChapterHelpers
ruby = User.create!(name: "Ruby Crystal")
david = User.create!(name: "David Heinemeier Hansson")
crystal_post = Post.create!(title: "Crystal for Rubyists", user: ruby)
rails_post = Post.create!(title: "Rails is the way", draft: false, user: david)
class ApplicationSerializer
  include Alba::Resource
  class << self
    def one(name, **options)
      options[:resource] ||= proc { |_obj| "#{name}Serializer".classify.constantize }
      super(name, **options)
    end
  end
end
class UserSerializer < ApplicationSerializer
  attributes :id, :short_name
  def short_name(user)
    user.name.squish.split(/\s/).then do |parts|
      parts[0..-2].map { _1[0] + "." }.join + parts.last
    end
  end
end
class PostSerializer < ApplicationSerializer
  attributes :id, :title
  attribute :is_draft, &:draft?
  one :user
end
class ApplicationController
  private
  def serialize(obj, with: nil)
    serializer = with || begin
      model = obj.try(:model) || obj.class
      "#{model.name}Serializer".constantize
    end
    serializer.new(obj)
  end
end
class PostsController < ApplicationController
  def index
    render json: serialize(Post.all)
  end
end
response = get "/posts"
puts response.body

================
File: Chapter08/prelude.rb
================
# frozen_string_literal: true
require_relative "../lib/helpers"
using ChapterHelpers
gems do
  gem "keynote", "1.1.1"
  gem "alba", "2.1.0"
end
schema do
  create_table :users, force: true do |t|
    t.string :name, null: true
    t.timestamps
  end
  create_table :posts, force: true do |t|
    t.string :title, null: false
    t.belongs_to :user, null: false
    t.datetime :published_at
    t.boolean :draft, null: false, default: true
    t.timestamps
  end
  create_table :books, force: true do |t|
    t.string :title, null: false
  end
  create_table :book_reads, force: true do |t|
    t.belongs_to :user, null: false
    t.belongs_to :book, null: false
    t.datetime :read_at
    t.float :score
    t.timestamps
  end
end
routes do
  resources :posts, only: [:index, :show]
  resources :users, only: [:show]
  namespace :admin do
    resources :users, only: [:show]
  end
  resources :books, only: [:index, :show]
end
require_relative "../lib/boot"
class User < ApplicationRecord
  has_many :posts
end
class Post < ApplicationRecord
  belongs_to :user
end
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end
class Book < ApplicationRecord
  has_many :book_reads
end
class BookRead < ApplicationRecord
  belongs_to :user
  belongs_to :book
  def read? = !!read_at
end
class User < ApplicationRecord
  has_many :book_reads
end
Alba.inflector = :active_support

================
File: Chapter09/views/books/_form.html.erb
================
<%= form_for(book, class: "contents") do |form| %>
  <% if book.errors.any? %>
    <div id="error_explanation" class="bg-red-50 text-red-500 px-3 py-2 font-medium rounded-lg mt-3">
      <ul>
        <% book.errors.each do |error| %>
          <li><%= error.full_message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div class="my-5">
    <%= form.label :title %>
    <%= form.text_field :title, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
  </div>

  <div class="my-5">
    <%= form.label :author %>
    <%= form.text_field :author, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %>
  </div>

  <div class="inline">
    <%= form.submit "Create", class: "rounded-lg py-3 px-5 bg-blue-600 text-white inline-block font-medium cursor-pointer" %>
  </div>
<% end %>

================
File: Chapter09/views/books/index.html.erb
================
<div class="flex flex-col w-1/3">
  <%- Book.all.find_each do |book| -%>
    <div id="book-<%= book.id %>" class="mt-2 border-b-grey border-b pb-2">
      <h1 class="text-xl">
        <%= link_to book.title, book, class: "text-blue-500 cursor-pointer hover:text-black" %>
      </h1>
    </div>
  <% end %>

  <%= link_to "Back to all", books_path, class: "mt-4" %>
</div>

================
File: Chapter09/views/books/new.html.erb
================
<div class="mx-auto md:w-2/3 w-full">
  <h1 class="font-bold text-4xl">Add book</h1>
  <%= render "form", book: @book %>
</div>

================
File: Chapter09/views/books/show.html.erb
================
<div class="flex flex-col">
  <p>
    <strong>Book:</strong> <%= @book.title %>
  </p>
  <p>
    <strong>Author:</strong> <%= @book.author %>
  </p>
  <p>
    <strong>ISBN:</strong> <%= @book.isbn || "Unknown" %>
  </p>
</div>

================
File: Chapter09/00-controller-authorization-check.rb
================
require_relative "./prelude"
using ChapterHelpers
# Populating data
user = User.create!(name: "Vova")
alice = User.create!(name: "Alice")
post = Post.create(user:, title: "Authorization != authentication")
class PostsController < ApplicationController
  before_action :authenticate! # authentication
  def destroy
    post = Post.find(params[:id])
    if post.user_id == current_user.id # authorization
      # context has been validated,
      # feel free to perform the action
      post.destroy
      redirect_to posts_path, notice: "Post has been deleted"
    else
      redirect_to posts_path, alert: "You are not allowed to delete this post"
    end
  end
end
response = delete "/posts/#{post.id}", cookies: {user_id: alice.id}
puts response.flash
Post.where(id: post.id).exists?
response = delete "/posts/#{post.id}", cookies: {user_id: user.id}
puts response.flash
Post.where(id: post.id).exists?

================
File: Chapter09/01-library-controller-authorization.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  enum :role, regular: "regular", admin: "admin",
    librarian: "librarian"
end
# Populating data
admin = User.admin.create!(name: "Admin")
librarian = User.librarian.create!(name: "Book Keeper")
reader = User.regular.create!(name: "George")
book = Book.create!(title: "Polished Ruby", author: "Jeremy Evans", isbn: "9781801072724")
book_2 = Book.create!(title: "Programming Ruby 3.2", author: "Noel Rappin", isbn: "9781680509823")
class BooksController < ApplicationController
  before_action :require_access, only: [:new, :create, :edit, :update, :destroy]
  def new
    @book = Book.new
  end
  def show
    @book = Book.find(params[:id])
  end
  private
  def require_access
    return if current_user&.librarian? ||
      current_user&.admin?
    redirect_to books_path, alert: "No access"
  end
end
response = get "/books/new", cookies: {user_id: reader.id}
puts [response.status, response.flash]
response = get "/books/new", cookies: {user_id: librarian.id}
puts [response.status, response.flash]

================
File: Chapter09/02-roles-permissions.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  enum :role, regular: "regular", admin: "admin",
    librarian: "librarian"
  REGULAR_PERMISSIONS = %i[
    browse_catalogue borrow_books
  ].freeze
  LIBRARIAN_PERMISSIONS = (
    REGULAR_PERMISSIONS + %i[manage_books]
  ).freeze
  ADMIN_PERMISSIONS = (
    LIBRARIAN_PERMISSIONS + %i[manage_librarians manage_all_books]
  ).freeze
  PERMISSIONS = {
    regular: REGULAR_PERMISSIONS,
    librarian: LIBRARIAN_PERMISSIONS,
    admin: ADMIN_PERMISSIONS
  }.freeze
  def permission?(name) =
    PERMISSIONS.fetch(role.to_sym)
      .include?(name)
end
# Populating data
admin = User.admin.create!(name: "Admin")
librarian = User.librarian.create!(name: "Book Keeper")
reader = User.regular.create!(name: "George")
book = Book.create!(title: "Polished Ruby", author: "Jeremy Evans", isbn: "9781801072724")
book_2 = Book.create!(title: "Programming Ruby 3.2", author: "Noel Rappin", isbn: "9781680509823")
class BooksController < ApplicationController
  before_action :require_access, only: [:new, :create, :edit, :update, :destroy]
  def new
    @book = Book.new
  end
  def show
    @book = Book.find(params[:id])
  end
  private
  def require_access
    return unless current_user&.permission?(:manage_books)
    redirect_to books_path, alert: "No access"
  end
end
response = get "/books/new", cookies: {user_id: reader.id}
puts [response.status, response.flash]
response = get "/books/new", cookies: {user_id: librarian.id}
puts [response.status, response.flash]

================
File: Chapter09/03-abac.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  enum :role, regular: "regular", admin: "admin",
    librarian: "librarian"
  REGULAR_PERMISSIONS = %i[
    browse_catalogue borrow_books
  ].freeze
  LIBRARIAN_PERMISSIONS = (
    REGULAR_PERMISSIONS + %i[manage_books]
  ).freeze
  ADMIN_PERMISSIONS = (
    LIBRARIAN_PERMISSIONS + %i[manage_librarians manage_all_books]
  ).freeze
  PERMISSIONS = {
    regular: REGULAR_PERMISSIONS,
    librarian: LIBRARIAN_PERMISSIONS,
    admin: ADMIN_PERMISSIONS
  }.freeze
  def permission?(name) =
    PERMISSIONS.fetch(role.to_sym)
      .include?(name)
end
# Add departments
class User < ApplicationRecord
  enum :dept, fic: "fic", nonfic: "nonfic",
    ref: "ref"
end
class Book < ApplicationRecord
  enum :dept, fic: "fic", nonfic: "nonfic",
    ref: "ref"
end
class BooksController < ApplicationController
  def destroy
    book = Book.find(params[:id])
    if current_user.permission?(:manage_all_books) || (
      current_user.permission?(:manage_books) &&
      book.dept == current_user.dept
    )
      book.destroy!
      redirect_to books_path, notice: "Removed"
    else
      redirect_to books_path, alert: "No access"
    end
  end
end
# Populating data
admin = User.admin.create!(name: "Admin")
librarian = User.librarian.ref.create!(name: "Book Keeper")
reader = User.regular.create!(name: "George")
fic_book = Book.fic.create!(title: "Python on Rails", author: "Unknown")
response = delete "/books/#{fic_book.id}", cookies: {user_id: reader.id}
puts [response.status, response.flash]
Book.where(id: fic_book.id).exists?
response = delete "/books/#{fic_book.id}", cookies: {user_id: librarian.id}
puts [response.status, response.flash]
Book.where(id: fic_book.id).exists?
response = delete "/books/#{fic_book.id}", cookies: {user_id: admin.id}
puts [response.status, response.flash]
Book.where(id: fic_book.id).exists?

================
File: Chapter09/04-poro-policy-objects.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  enum :role, regular: "regular", admin: "admin",
    librarian: "librarian"
  enum :dept, fic: "fic", nonfic: "nonfic",
    ref: "ref"
  REGULAR_PERMISSIONS = %i[
    browse_catalogue borrow_books
  ].freeze
  LIBRARIAN_PERMISSIONS = (
    REGULAR_PERMISSIONS + %i[manage_books]
  ).freeze
  ADMIN_PERMISSIONS = (
    LIBRARIAN_PERMISSIONS + %i[manage_librarians manage_all_books]
  ).freeze
  PERMISSIONS = {
    regular: REGULAR_PERMISSIONS,
    librarian: LIBRARIAN_PERMISSIONS,
    admin: ADMIN_PERMISSIONS
  }.freeze
  def permission?(name) =
    PERMISSIONS.fetch(role.to_sym)
      .include?(name)
end
class Book < ApplicationRecord
  enum :dept, fic: "fic", nonfic: "nonfic",
    ref: "ref"
end
# Populating data
librarian = User.librarian.ref.create!(name: "Book Keeper")
fic_librarian = User.librarian.fic.create!(name: "Fiction Keeper")
fic_book = Book.fic.create!(title: "Python on Rails", author: "Unknown")
class BookPolicy
  attr_reader :user, :book
  def initialize(user, book)
    @user, @book = user, book
  end
  def destroy?
    user.permission?(:manage_all_books) || (
      user.permission?(:manage_books) &&
      book.dept == user.dept
    )
  end
end
class BooksController < ApplicationController
  def destroy
    book = Book.find(params[:id])
    if BookPolicy.new(current_user, book).destroy?
      book.destroy!
      redirect_to books_path, notice: "Removed"
    else
      redirect_to books_path, alert: "No access"
    end
  end
end
response = delete "/books/#{fic_book.id}", cookies: {user_id: librarian.id}
puts [response.status, response.flash]
Book.where(id: fic_book.id).exists?
response = delete "/books/#{fic_book.id}", cookies: {user_id: fic_librarian.id}
puts [response.status, response.flash]
Book.where(id: fic_book.id).exists?

================
File: Chapter09/05-action-policy.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  enum :role, regular: "regular", admin: "admin",
    librarian: "librarian"
  enum :dept, fic: "fic", nonfic: "nonfic",
    ref: "ref"
  REGULAR_PERMISSIONS = %i[
    browse_catalogue borrow_books
  ].freeze
  LIBRARIAN_PERMISSIONS = (
    REGULAR_PERMISSIONS + %i[manage_books]
  ).freeze
  ADMIN_PERMISSIONS = (
    LIBRARIAN_PERMISSIONS + %i[manage_librarians manage_all_books]
  ).freeze
  PERMISSIONS = {
    regular: REGULAR_PERMISSIONS,
    librarian: LIBRARIAN_PERMISSIONS,
    admin: ADMIN_PERMISSIONS
  }.freeze
  def permission?(name) =
    PERMISSIONS.fetch(role.to_sym)
      .include?(name)
end
class Book < ApplicationRecord
  enum :dept, fic: "fic", nonfic: "nonfic",
    ref: "ref"
end
# Populating data
librarian = User.librarian.ref.create!(name: "Book Keeper")
fic_librarian = User.librarian.fic.create!(name: "Fiction Keeper")
fic_book = Book.fic.create!(title: "Python on Rails", author: "Unknown")
class BookPolicy < ApplicationPolicy
  def view? = true
  def manage?
    permission?(:manage_all_books) || (
      permission?(:manage_books) &&
      book.dept == user.dept
    )
  end
end
class BooksController < ApplicationController
  def index = authorize!
  def destroy
    book = Book.find(params[:id])
    authorize! book
    book.destroy!
    redirect_to books_path, notice: "Removed"
  end
end
response = delete "/books/#{fic_book.id}", cookies: {user_id: librarian.id}
puts [response.status, response.flash]
Book.where(id: fic_book.id).exists?
response = delete "/books/#{fic_book.id}", cookies: {user_id: fic_librarian.id}
puts [response.status, response.flash]
Book.where(id: fic_book.id).exists?
# Testing authorization enforcement
require "action_policy/test_helper"
class BooksTest < ActionDispatch::IntegrationTest
  include ActionPolicy::TestHelper
  test "is authorized" do
    assert_authorized_to(:view?, Book) do
      get "/books"
    end
    assert_response :success
  end
end
Minitest.run

================
File: Chapter09/06-authorization-in-views.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  enum :role, regular: "regular", admin: "admin",
    librarian: "librarian"
  enum :dept, fic: "fic", nonfic: "nonfic",
    ref: "ref"
end
class Book < ApplicationRecord
  enum :dept, fic: "fic", nonfic: "nonfic",
    ref: "ref"
end
class BookPolicy < ApplicationPolicy
  def manage?
    user.admin? || (
      user.librarian? &&
        book.dept == user.dept
    )
  end
end
# Populating data
reader = User.regular.create!(name: "Vova")
librarian = User.librarian.ref.create!(name: "Book Keeper")
fic_librarian = User.librarian.fic.create!(name: "Fiction Keeper")
book = Book.fic.create!(title: "Python on Rails", author: "Unknown")
template = <<~ERB # :ignore:output
  <li>
    <%= book.title %>
    <% if allowed_to?(:destroy?, book) %>
      <%= button_to "Delete", book, method: :delete %>
    <% end %>
  </li>
ERB
Current.set(user: reader) do
  binding.render(template)
end
Current.set(user: librarian) do
  binding.render(template)
end
Current.set(user: fic_librarian) do
  binding.render(template)
end

================
File: Chapter09/07-search-form-authorization.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  enum :role, regular: "regular", admin: "admin",
    librarian: "librarian"
end
module Books
  class SearchForm < ApplicationForm
    attribute :q
    attribute :isbn
    attribute :book_id
  end
end
# Populating data
reader = User.regular.create!(name: "Vova")
librarian = User.librarian.create!(name: "Book Keeper")
admin = User.admin.create!(name: "Library Admin")
template = <<~ERB # :ignore:output
  <%= form_for Books::SearchForm.new do |f| %>
    <%= f.text_field :q, placeholder: "Type a query.." %>
  <%- if current_user.librarian? || current_user.admin? -%>
    <%= f.text_field :isbn, placeholder: "ISNB" %>
  <%- end -%>
  <%- if current_user.admin? -%>
    <%= f.text_field :book_id, placeholder: "Book ID" %>
  <%- end -%>
  <% end %>
ERB
Current.set(user: reader) do
  binding.render(template)
end
Current.set(user: librarian) do
  binding.render(template)
end
Current.set(user: admin) do
  binding.render(template)
end
# Migrating to policies
class BookPolicy < ApplicationPolicy
  def search_by_isbn? = user.librarian? || user.admin?
  def search_by_id? = user.admin?
end
template = <<~ERB # :ignore:output
  <%= form_for Books::SearchForm.new do |f| %>
    <%= f.text_field :q, placeholder: "Type a query.." %>
  <%- if allowed_to?(:search_by_isbn?, Book) -%>
    <%= f.text_field :isbn, placeholder: "ISNB" %>
  <%- end -%>
  <%- if allowed_to?(:search_by_id?, Book) -%>
    <%= f.text_field :book_id, placeholder: "Book ID" %>
  <%- end -%>
  <% end %>
ERB
Current.set(user: reader) do
  binding.render(template)
end
Current.set(user: librarian) do
  binding.render(template)
end
Current.set(user: admin) do
  binding.render(template)
end
# Policy with the filtered params list
class BookPolicy < ApplicationPolicy
  def search_params
    [].tap do
      _1 << :isbn if user.admin? || user.librarian?
      _1 << :book_id if user.admin?
    end
  end
end
template = <<~ERB # :ignore:output
  <%- policy = BookPolicy.new(user: current_user) -%>
  <%= form_for Books::SearchForm.new do |f| %>
    <%= f.text_field :q, placeholder: "Type a query.." %>
  <%- if policy.search_params.include?(:isbn) -%>
    <%= f.text_field :isbn, placeholder: "ISNB" %>
  <%- end -%>
  <%- if policy.search_params.include?(:book_id) -%>
    <%= f.text_field :book_id, placeholder: "Book ID" %>
  <%- end -%>
  <% end %>
ERB
Current.set(user: reader) do
  binding.render(template)
end
Current.set(user: librarian) do
  binding.render(template)
end
Current.set(user: admin) do
  binding.render(template)
end
# Proposed interface for authorization integrated into form objects
<<~ERB # :ignore:output
  <% search_form = Books::SearchForm.new %>
  <%= form_for search_form do |f| %>
    <%= f.text_field :q, placeholder: "Type a query.." %>
    <% if search_form.field_allowed?(:isbn) %>
      <%= f.text_field :isbn, placeholder: "ISNB" %>
    <% end %>
    <% if search_form.field_allowed?(:book_id) %>
      <%= f.text_field :book_id, placeholder: "Book ID" %>
    <% end %>
  <% end %>
ERB

================
File: Chapter09/08-n-plus-one-authorization.rb
================
require_relative "./prelude"
using ChapterHelpers
class User
  has_many :posts
  enum :role, regular: "regular", admin: "admin",
    librarian: "librarian"
end
class PostPolicy < ApplicationPolicy
  # Assuming that there is a limit on the number of drafts
  def publish? = user.admin? || (
    (user.id == post.user_id) && user.posts.where(published_at: nil).size < 20
  )
  def manage? = user.admin? || (user.id == post.user_id)
end
# Generate data
user = User.create!(name: "Vova")
admin = User.admin.create!(name: "Admin")
40.times { Post.create!(title: "Post ##{_1}", user:) }
posts = Post.all.to_a
template = <<~ERB # :ignore:output
  <%- posts.each do |post| %>
    <div>
      <%= link_to post.title, post %>
      <% if allowed_to?(:publish?, post) %>
        <%= button_to "Publish", publish_post_path(post), method: :patch %>
      <% end %>
      <% if allowed_to?(:edit?, post) %>
        <%= link_to "Edit", edit_post_path(post) %>
      <% end %>
      <% if allowed_to?(:destroy?, post) %>
        <%= button_to "Delete", post, method: :delete %>
      <% end %>
    </div>
  <% end %>
ERB
# Enable view logger to show runtime metrics
ActionView::Base.logger = ActiveSupport::Logger.new($stdout) # :ignore:
Current.set(user:) do
  ApplicationController.render(
    locals: {posts:},
    inline: template
  )
end
Current.set(user: admin) do
  ApplicationController.render(
    locals: {posts:},
    inline: template
  )
end

================
File: Chapter09/09-scoping-based-authorization.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  enum :role, regular: "regular", admin: "admin",
    librarian: "librarian"
  enum :dept, fic: "fic", nonfic: "nonfic",
    ref: "ref"
  REGULAR_PERMISSIONS = %i[
    browse_catalogue borrow_books
  ].freeze
  LIBRARIAN_PERMISSIONS = (
    REGULAR_PERMISSIONS + %i[manage_books]
  ).freeze
  ADMIN_PERMISSIONS = (
    LIBRARIAN_PERMISSIONS + %i[manage_librarians manage_all_books]
  ).freeze
  PERMISSIONS = {
    regular: REGULAR_PERMISSIONS,
    librarian: LIBRARIAN_PERMISSIONS,
    admin: ADMIN_PERMISSIONS
  }.freeze
  def permission?(name) =
    PERMISSIONS.fetch(role.to_sym)
      .include?(name)
end
class Book < ApplicationRecord
  enum :dept, fic: "fic", nonfic: "nonfic",
    ref: "ref"
end
# Populating data
librarian = User.librarian.ref.create!(name: "Book Keeper")
fic_librarian = User.librarian.fic.create!(name: "Fiction Keeper")
fic_book = Book.fic.create!(title: "Python on Rails", author: "Unknown")
class BookPolicy < ApplicationPolicy
  relation_scope(:destroyable) do |scope|
    next scope.all if permission?(:manage_all_books)
    next scope.where(dept: user.dept) if permission?(:manage_books)
    scope.none
  end
end
class BooksController < ApplicationController
  def destroy
    book = authorized_scope(Book.all, as: :destroyable)
      .find(params[:id])
    book.destroy!
    redirect_to books_path, notice: "Removed"
  end
end
response = delete "/books/#{fic_book.id}", cookies: {user_id: librarian.id}
puts [response.status, response.flash]
Book.where(id: fic_book.id).exists?
response = delete "/books/#{fic_book.id}", cookies: {user_id: fic_librarian.id}
puts [response.status, response.flash]
Book.where(id: fic_book.id).exists?

================
File: Chapter09/prelude.rb
================
require_relative "../lib/helpers"
using ChapterHelpers
gems do
  gem "action_policy", "0.6.5"
end
schema do
  create_table :users, force: true do |t|
    t.string :name, null: true
    t.string :role, null: false, default: "regular"
    t.string :dept, null: true
    t.timestamps
  end
  create_table :posts, force: true do |t|
    t.string :title, null: false
    t.belongs_to :user, null: false
    t.datetime :published_at
    t.timestamps
  end
  create_table :books, force: true do |t|
    t.string :title, null: false
    t.string :author, null: false
    t.string :isbn, null: true
    t.string :dept, null: true
    t.timestamps
  end
end
routes do
  resources :posts, only: [:index, :show, :destroy, :edit] do
    patch :publish, on: :member
  end
  resources :books, only: [:index, :new, :show, :edit, :update, :destroy]
  namespace :books do
    post "/search" => "book/search#create", :as => :searches
  end
end
require_relative "../lib/boot"
require "action_policy/rails/scope_matchers/active_record"
class ApplicationController
  rescue_from ActionPolicy::Unauthorized do |err|
    redirect_back(fallback_location: books_path, alert: err.result.message)
  end
  rescue_from ActiveRecord::RecordNotFound do |err|
    redirect_back(fallback_location: books_path, alert: "Not found")
  end
  private
  def authenticate!
    render head: :unauthenticated unless current_user
  end
end
class User < ApplicationRecord
end
class Post < ApplicationRecord
  belongs_to :user
end
class Book < ApplicationRecord
end
class ApplicationForm
  include ActiveModel::API
  include ActiveModel::Attributes
  def save
    return false unless valid?
    submit!
  end
  def model_name
    ActiveModel::Name.new(nil, nil, self.class.name.sub(/Form$/, ""))
  end
  private
  def submit!
    raise NotImplementedError
  end
end
class ApplicationPolicy < ActionPolicy::Base
  authorize :user, allow_nil: true
  delegate :permission?, to: :user
  # The features below will be added in Action Policy v1.0
  alias_rule :index?, :show?, to: :view?
  class << self
    def inherited(subclass)
      # define a resource-named reader as a #resource alias
      resource_reader = subclass.name.demodulize.sub(/Policy$/, "").underscore
      alias_method :"#{resource_reader}", :record
    end
  end
end

================
File: Chapter10/views/user_mailer/welcome.html.erb
================
<h1>Welcome to the club, <%= @user.name %>!</h1>
<p>We hope you will enjoy working with us!</h1>

================
File: Chapter10/00-mailer.rb
================
require_relative "./prelude"
using ChapterHelpers
class UserMailer < ApplicationMailer
  def welcome(user)
    @user = user
    mail(
      to: @user.email,
      subject: "Welcome to the club!"
    )
  end
end
user = User.create!(name: "Vova", email: "me@example.test")
UserMailer.welcome(user).deliver_later

================
File: Chapter10/01-service-notifications.rb
================
require_relative "./prelude"
using ChapterHelpers
# Populating data
user = User.create!(name: "Vova", email: "me@example.test")
alice = User.create!(
  name: "Alice",
  email: "alice@example.test",
  phone_number: "+1 234 567-8900",
  notifications_enabled: true,
  email_notifications_enabled: true,
  sms_notifications_enabled: true
)
post = Post.create!(title: "A slice of Rails", user:)
user.subscribers << alice
class Post::Publish < ApplicationService
  param :post
  def call
    post.update!(
      published_at: Time.current,
      status: :published
    )
    notify_subscribers
  end
  private
  def notify_subscribers
    post.user.subscribers.each do |user|
      next unless user.email_notifications_enabled?
      PostMailer.with(user:)
        .published(post).deliver_later
    end
  end
end
Post::Publish.call(post)
# Adding more notification channels
class Post::Publish
  def notify_subscribers
    payload = post.slice(:id, :title)
      .merge(event: "post.published")
    post.user.subscribers.each do |user|
      NotificationsChannel.broadcast_to(user, payload)
      next unless user.notifications_enabled?
      if user.email_notifications_enabled?
        PostMailer.with(user:)
          .published(post).deliver_later
      end
      if user.sms_notifications_enabled?
        SMSSender.new(user.phone_number).send_later(
          body: "Post has been published: #{post.title}"
        )
      end
    end
  end
end
new_post = Post.create!(title: "Ruby on Rails returns", user:)
Post::Publish.call(new_post)

================
File: Chapter10/02-custom-delivery-service.rb
================
require_relative "./prelude"
using ChapterHelpers
# Populating data
user = User.create!(name: "Vova", email: "me@example.test")
alice = User.create!(
  name: "Alice",
  email: "alice@example.test",
  phone_number: "+1 234 567-8900",
  notifications_enabled: true,
  email_notifications_enabled: true,
  sms_notifications_enabled: true
)
post = Post.create!(title: "A slice of Rails", user:)
user.subscribers << alice
class Post::NotifyPublished < ApplicationService
  param :post
  def call
    payload = post.slice(:id, :title)
      .merge(event: "post.published")
    post.user.subscribers.each do |user|
      NotificationsChannel.broadcast_to(user, payload)
      next unless user.notifications_enabled?
      if user.email_notifications_enabled?
        PostMailer.with(user:)
          .published(post).deliver_later
      end
      if user.sms_notifications_enabled?
        SMSSender.new(user.phone_number).send_later(
          body: "Post has been published: #{post.title}"
        )
      end
    end
  end
end
class Post
  class Publish < ApplicationService
    param :post
    def call
      post.update!(
        published_at: Time.current,
        status: :published
      )
      NotifyPublished.call(post)
    end
  end
end
Post::Publish.call(post)
require_relative "rails_helper"
RSpec.describe Post::Publish do
  let(:post) { Post.create!(title: "Test") }
  subject { described_class.call(post) }
  before { allow(Post::NotifyPublished).to receive(:call) }
  it "marks the post as published and sets published_at" do
    subject
    expect(post.reload.published_at).not_to be_nil
    expect(post).to be_published
  end
  it "triggers notification via NotifyPublished" do
    subject
    expect(Post::NotifyPublished)
      .to have_received(:call).with(post)
  end
end
RSpec::Core::Runner.run([])

================
File: Chapter10/03-pluggable-delivery-sketch.rb
================
require_relative "./prelude"
using ChapterHelpers
# Populating data
user = User.create!(name: "Vova", email: "me@example.test")
alice = User.create!(
  name: "Alice",
  email: "alice@example.test",
  phone_number: "+1 234 567-8900",
  notifications_enabled: true,
  email_notifications_enabled: true,
  sms_notifications_enabled: true
)
post = Post.create!(title: "A slice of Rails", user:)
user.subscribers << alice
class ApplicationNotifier < ApplicationService
  class << self
    def plug(delivery_method, **options)
      plugins << [delivery_method, options]
    end
    # FIXME: Doesn't support inheritance
    def plugins = @plugins ||= []
  end
  def notify(user, ...)
    plugins.each { _1.notify(user, ...) }
  end
  private
  def plugins
    self.class.plugins.filter_map do |id, opts|
      plugin_class = "#{id.to_s.classify}NotifierPlugin".safe_constantize
      next unless plugin_class
      plugin_class.new(**opts)
    end
  end
end
class MailerNotifierPlugin
  attr_reader :class_name, :action
  def initialize(class_name:, action:)
    @class_name, @action = class_name, action
  end
  def notify(user, ...)
    return unless user.notifications_enabled? &&
      user.email_notifications_enabled?
    mailer = class_name.constantize.with(user:)
    mailer.public_send(action, ...).deliver_later
  end
end
class Post::NotifyPublished < ApplicationNotifier
  plug :mailer, class_name: "PostMailer",
    action: "published"
  plug :sms, content: ->(post) { "Post has been published: #{post.title}" }
  plug :cable, event: "post.published",
    payload: ->(post) { post.slice(:id, title) }
  param :post
  def call
    post.user.subscribers.each { notify(_1, post) }
  end
end
Post::NotifyPublished.call(post)

================
File: Chapter10/04-active-delivery.rb
================
require_relative "./prelude"
using ChapterHelpers
# Populating data
author = User.create!(name: "Vova", email: "me@example.test")
alice = User.create!(
  name: "Alice",
  email: "alice@example.test",
  phone_number: "+1 234 567-8900",
  notifications_enabled: true,
  email_notifications_enabled: true,
  sms_notifications_enabled: true
)
rails_post = Post.create!(title: "A slice of Rails", user: author)
author.subscribers << alice
class ApplicationDelivery < ActiveDelivery::Base
  before_notify :ensure_enabled
  before_notify :ensure_mailer_enabled, on: :mailer
  def ensure_enabled = !!user&.notifications_enabled?
  def ensure_mailer_enabled
    !!user&.email_notifications_enabled?
  end
  def user = params[:user]
end
class PostDelivery < ApplicationDelivery
  delivers :published
end
class Post::Publish < ApplicationService
  param :post
  def call
    post.update!(
      published_at: Time.current,
      status: :published
    )
    notify_subscribers
  end
  private
  def notify_subscribers
    post.user.subscribers.each do |user|
      PostDelivery.with(user:)
        .published(post).deliver_later
    end
  end
end
Post::Publish.call(rails_post)
# Adding SMS notifier
class ApplicationSMSNotifier < AbstractNotifier::Base
  self.driver = proc do |data|
    data => {to:, body:}
    SMSSender.new(to).send_now(body:)
  end
  private def user = params[:user]
end
class PostSMSNotifier < ApplicationSMSNotifier
  def published(post)
    notification(
      to: user.phone_number,
      body: "Post has been published: #{post.title}"
    )
  end
end
class ApplicationDelivery < ActiveDelivery::Base
  register_line :sms, notifier: true, suffix: "SMSNotifier"
  before_notify :ensure_sms_enabled, on: :sms
  private
  def ensure_sms_enabled
    !!user&.sms_notifications_enabled?
  end
end
# Reset memoized lines to use the new one:
PostDelivery.remove_instance_variable(:@lines) # :ignore:
new_post = Post.create!(title: "Ruby on Rails returns", user: author)
Post::Publish.call(new_post)
# Testing deliveries and notifiers
require_relative "rails_helper"
RSpec.describe Post::Publish do
  let(:user) { User.create!(name: "Author", email: "author@ex.test") }
  let(:post) { Post.create!(title: "Test", user: author) }
  let!(:subscriber) do
    User.create!(name: "Tester", email: "a@ex.test").tap { post.user.subscribers << _1 }
  end
  subject { described_class.call(post) }
  it "triggers delivery to subscribers" do
    expect { subject }.to have_delivered_to(
      PostDelivery, :published, post
    ).with(
      user: subscriber
    )
  end
end
RSpec.describe PostDelivery do
  let(:user) { User.new(phone_number: "311") }
  let(:delivery) { described_class.with(user:) }
  describe "#published" do
    let(:post) { Post.new(title: "A") }
    subject { delivery.published(post).deliver_now }
    it "notifies via SMS" do
      expect { subject }.to have_sent_notification(
        via: PostSMSNotifier,
        to: "311",
        body: "Post has been published: A"
      )
    end
  end
end
RSpec::Core::Runner.run([])

================
File: Chapter10/05-noticed.rb
================
require_relative "./prelude"
using ChapterHelpers
# Populating data
author = User.create!(name: "Vova", email: "me@example.test")
alice = User.create!(
  name: "Alice",
  email: "alice@example.test",
  phone_number: "+1 234 567-8900",
  notifications_enabled: true,
  email_notifications_enabled: true,
  sms_notifications_enabled: true
)
rails_post = Post.create!(title: "A slice of Rails", user: author)
author.subscribers << alice
class SMSDelivery < Noticed::DeliveryMethods::Base
  def deliver
    notification.sms_params => {to:, body:}
    SMSSender.new(to).send_now(body:)
  end
end
class PostMailer < ApplicationMailer
  def published
    @post = params[:post]
    @user = params[:recipient]
    mail(
      to: @user.email,
      subject: "A new post has been published!",
      body: "Check out #{@post.title}!"
    )
  end
end
class PostPublishedNotification < Noticed::Base
  deliver_by :email, mailer: "PostMailer",
    method: :published, if: :email?
  deliver_by :sms, class: "SMSDelivery", if: :sms?
  deliver_by :action_cable, channel: "NotificationsChannel", format: :cable_payload
  def cable_payload =
    post.slice(:id, :title).merge(
      event: "post.published"
    )
  def sms_params =
    {
      to: user.phone_number,
      body: "Post has been published: #{post.title}"
    }
  private
  alias_method :user, :recipient
  def post = params[:post]
  def email? = user.notifications_enabled? &&
    user.email_notifications_enabled?
  def sms? = user.notifications_enabled? &&
    user.sms_notifications_enabled?
end
class Post::Publish < ApplicationService
  param :post
  def call
    post.update!(
      published_at: Time.current,
      status: :published
    )
    notify_subscribers
  end
  private
  def notify_subscribers
    PostPublishedNotification.with(post:).deliver_later(
      post.user.subscribers
    )
  end
end
Post::Publish.call(rails_post)

================
File: Chapter10/06-bitfield-notifications.rb
================
require_relative "./prelude"
using ChapterHelpers
class User < ApplicationRecord
  self.table_name = "bit_users"
  NOTIFICATION_BITS = {
    all: 1,
    email: 3,
    sms: 5
  }.freeze
  def notifications_enabled? =
    (notification_bits & 1 == 1)
  def email_notifications_enabled? =
    (notification_bits & 3 == 3)
  def sms_notifications_enabled? =
    (notification_bits & 5 == 5)
end
u1 = User.new(notification_bits: User::NOTIFICATION_BITS[:email])
u1.notifications_enabled?
u1.email_notifications_enabled?
u1.sms_notifications_enabled?
u2 = User.new(notification_bits: User::NOTIFICATION_BITS[:sms])
u2.notifications_enabled?
u2.email_notifications_enabled?
u2.sms_notifications_enabled?
# Adding a value object
class User::Notifications
  BITS = {
    all: 1,
    email: 3,
    sms: 5
  }.freeze
  private attr_reader :val
  def initialize(value) = @val = value
  def enabled? = (val & 1 == 1)
  def email? = (val & 3 == 3)
  def sms? = (val & 5 == 5)
end
class User < ApplicationRecord
  def notifications =
    @notifications ||=
      Notifications.new(notification_bits)
end
u1.notifications.enabled?
u1.notifications.email?
u1.notifications.sms?

================
File: Chapter10/07-store-model-notifications.rb
================
require_relative "./prelude"
using ChapterHelpers
class User::Notifications
  include StoreModel::Model
  attribute :enabled, :boolean, default: true
  attribute :email_enabled, :boolean, default: true
  attribute :sms_enabled, :boolean, default: true
  attribute :email, :string
  attribute :phone_number, :string
  def email_enabled? = enabled? && super
  def sms_enabled? = enabled? && super
end
class User < ApplicationRecord
  self.table_name = "store_users"
  attribute :notifications, Notifications.to_type
end
user = User.new(notifications: {enabled: "t", email_enabled: "t", sms_enabled: "f"})
user.notifications.enabled?
user.notifications.email_enabled?
user.notifications.sms_enabled?
user.save!
user.reload
user.notifications.sms_enabled = true
user.save!
user.reload
user.notifications.enabled?
user.notifications.email_enabled?
user.notifications.sms_enabled?

================
File: Chapter10/prelude.rb
================
require_relative "../lib/helpers"
using ChapterHelpers
gems do
  # For service objects
  gem "dry-initializer", "3.1.1"
  # Do not require right away to activate the mailer line,
  # which requires loading ActiveDelivery after Action Mailer
  gem "active_delivery", "~> 1.0.0", require: false
  gem "noticed", "1.6.0"
  gem "store_model", "1.6.2"
  # For specs
  gem "rspec-rails", "6.1.0"
end
schema do
  create_table :users, force: true do |t|
    t.string :name, null: true
    t.string :email, null: false
    t.string :phone_number, null: true
    t.boolean :notifications_enabled, null: false, default: true
    t.boolean :email_notifications_enabled, null: false, default: true
    t.boolean :sms_notifications_enabled, null: false, default: true
    t.timestamps
  end
  create_table :posts, force: true do |t|
    t.string :title, null: false
    t.belongs_to :user, null: false
    t.string :status, null: false, default: "draft"
    t.datetime :published_at
    t.timestamps
  end
  create_table :subscriptions, force: true do |t|
    t.belongs_to :user, null: false
    t.belongs_to :author, null: false
    t.timestamps
  end
  create_table :bit_users, force: true do |t|
    t.string :name, null: true
    t.string :email, null: true
    t.integer :notification_bits, null: false, default: 0
    t.timestamps
  end
  create_table :store_users, force: true do |t|
    t.string :name, null: true
    t.string :email, null: true
    t.json :notifications, null: false, default: {}
    t.timestamps
  end
end
require_relative "../lib/boot"
require "active_delivery"
class ApplicationService
  extend Dry::Initializer
  def self.call(...) = new(...).call
end
class User < ApplicationRecord
  has_many :posts, dependent: :destroy
  has_many :subscriptions, foreign_key: :author_id, dependent: :destroy
  has_many :subscribers, through: :subscriptions, source: :user
end
class Subscription < ApplicationRecord
  belongs_to :user
  belongs_to :author, class_name: "User"
end
class Post < ApplicationRecord
  belongs_to :user
  enum status: {draft: "draft", published: "published"}
end
class PostMailer < ApplicationMailer
  def published(post)
    mail(
      to: params[:user].email,
      subject: "A new post has been published!",
      body: "Check out #{post.title}!"
    )
  end
end
class NotificationsChannel < ApplicationCable::Channel
  def subscribed
    stream_for user
  end
end
class SMSSender
  attr_reader :number
  def initialize(number) = @number = number
  def send_later(body:)
    return unless number
    puts "[SMS MESSAGE ENQUEUED] to=#{number} body=#{body}"
  end
  def send_now(body:)
    return unless number
    puts "[SMS MESSAGE SENT] to=#{number} body=#{body}"
  end
end

================
File: Chapter10/rails_helper.rb
================
# frozen_string_literal: true
require "rspec/rails"
require "active_delivery/testing"
require "abstract_notifier/testing"
require "active_delivery/testing/rspec"
require "abstract_notifier/testing/rspec"
AbstractNotifier.delivery_mode = :test
RSpec.configure do |config|
  config.use_transactional_fixtures = true
end

================
File: Chapter11/views/01/quizzes/_student_result.html.erb
================
<div class="w-[400px] rounded-lg bg-white p-6 shadow flex flex-row">
  <%= render "courses/side_info", course: quiz.course %>
  <div class="w-full">
    <header class="flex flex-row justify-between">
      <h3
        class="mb-2 text-xl font-medium leading-tight text-neutral-800">
        <%= quiz.title %>
      </h3>
      <span class="<%= result.passed? ? "text-green-500" : "text-red-500"%>">
        <%= result.passed? ? "passed" : "failed" %>
      </span>
    </header>
    <p>
      <i class="fa fa-user"></i>
      <%= link_to result.user.name, result.user, class: "text-blue-600 cursor-pointer hover:underline" %>
    </p>
    <div class="flex flex-row items-baseline mr-2">
      <label class="text-sm text-gray-500 mr-1">Score</label>
      <span><%= result.score %> / <%= quiz.score %> (<%= l(result.created_at, format: :short) %>)</span>
    </div>
    <%- if result.attempt > 1 -%>
      <div class="flex flex-row items-baseline mr-2">
        <label class="text-sm text-gray-500 mr-1">Previous Attempt</label>
        <span><%= prev_result.score %> / <%= quiz.score %>
        (<%= l(prev_result.created_at, format: :short) %>)</span>
      </div>
    <%- end -%>
  </div>
</div>

================
File: Chapter11/views/02/quizzes/_student_result.html.erb
================
<%# locals: (quiz:, result:, prev_result: nil) -%>
<div class="w-[400px] rounded-lg bg-white p-6 shadow flex flex-row">
  <div class="w-full">
    <header class="flex flex-row justify-between">
      <h3
        class="mb-2 text-xl font-medium leading-tight text-neutral-800">
        <%= quiz.title %>
      </h3>
      <span class="<%= result.passed? ? "text-green-500" : "text-red-500"%>">
        <%= result.passed? ? "passed" : "failed" %>
      </span>
    </header>
    <p>
      <i class="fa fa-user"></i>
      <%= link_to result.user.name, result.user, class: "text-blue-600 cursor-pointer hover:underline" %>
    </p>
    <div class="flex flex-row items-baseline mr-2">
      <label class="text-sm text-gray-500 mr-1">Score</label>
      <span><%= result.score %> / <%= quiz.score %> (<%= l(result.created_at, format: :short) %>)</span>
    </div>
    <%- if result.attempt > 1 && prev_result -%>
      <div class="flex flex-row items-baseline mr-2">
        <label class="text-sm text-gray-500 mr-1">Previous Attempt</label>
        <span><%= prev_result.score %> / <%= quiz.score %>
        (<%= l(prev_result.created_at, format: :short) %>)</span>
      </div>
    <%- end -%>
  </div>
</div>

================
File: Chapter11/views/02/results/index.html.erb
================
<div class="w-full p-4">
  <%= form_with(url: search_results_path, class: "relative mb-4 flex w-[400px] shadow-sm flex-wrap items-stretch") do |f| %>
    <%= f.text_field :q, placeholder: "Search results by quiz title or student name", class: "min-w-0 flex-auto relative block rounded-l border border-gray-200 outline-none px-3 py-2 focus:border-blue-300" %>
    <%= f.button(type: :submit, class: "rounded-r py-3 px-5 bg-blue-600 text-white inline-block font-medium cursor-pointer hover:bg-blue-500 active:bg-blue-700") do %>
      <i class="fa fa-search"></i>
    <%- end -%>
  <% end %>
  <%= @results.find_each do |result| %>
    <%- @course = result.quiz.course -%>
    <%- prev_result = result.quiz.results.where(user: result.user, attempt: ...result.attempt).order(attempt: :desc).first -%>
    <%= render partial: "quizzes/student_result", locals: {result:, quiz: result.quiz, prev_result:} %>
  <% end %>
</div>

================
File: Chapter11/views/03/results/index.html.erb
================
<div class="w-full p-4">
  <%= form_with(url: search_results_path, class: "relative mb-4 flex w-full shadow-sm flex-wrap items-stretch") do |f| %>
    <div class="absolute z-[2] inset-y-4 left-0 flex items-center pl-3 pointer-events-none w-5 h-5">
      <i class="fa fa-search text-gray-400"></i>
    </div>
    <%= f.text_field :q, placeholder: "Search results by quiz title or student name", class: "min-w-0 flex-auto relative block rounded border border-gray-200 outline-none px-3 py-3 focus:border-blue-300 placeholder-gray-400 pl-10" %>
    <%= f.submit "Search", class: "absolute right-2.5 bottom-2.5 rounded p-1.5 px-2 text-sm bg-blue-600 text-white inline-block font-medium cursor-pointer hover:bg-blue-500 active:bg-blue-700" %>
  <% end %>
  <%= @results.find_each do |result| %>
    <%- @course = result.quiz.course -%>
    <%- prev_result = result.quiz.results.where(user: result.user, attempt: ...result.attempt).order(attempt: :desc).first -%>
    <%= render partial: "quizzes/student_result", locals: {result:, quiz: result.quiz, prev_result:} %>
  <% end %>
</div>

================
File: Chapter11/views/04/results/index.html.erb
================
<div class="w-full p-4">
  <%= search_box(url: search_results_path, placeholder: "Search results by quiz title or student name") %>
  <%= @results.find_each do |result| %>
    <%- @course = result.quiz.course -%>
    <%- prev_result = result.quiz.results.where(user: result.user, attempt: ...result.attempt).order(attempt: :desc).first -%>
    <%= render partial: "quizzes/student_result", locals: {result:, quiz: result.quiz, prev_result:} %>
  <% end %>
</div>

================
File: Chapter11/views/05/components/search_box/_component.html.erb
================
<%= form_with(url: c.action, class: "relative mb-4 flex w-full shadow-sm flex-wrap items-stretch") do |f| %>
  <div class="absolute z-[2] inset-y-4 left-0 flex items-center pl-3 pointer-events-none w-5 h-5">
    <i class="fa fa-search text-gray-400"></i>
  </div>
  <%= f.search_field :q, placeholder: c.placeholder, class: "min-w-0 flex-auto relative block rounded border border-gray-200 outline-none px-3 py-3 focus:border-blue-300 placeholder-gray-400 pl-10" %>
  <% if c.button? %>
    <%= f.submit "Search", class: "absolute right-2.5 bottom-2.5 rounded p-1.5 px-2 text-sm bg-blue-600 text-white inline-block font-medium cursor-pointer hover:bg-blue-500 active:bg-blue-700" %>
  <% end %>
<% end %>

================
File: Chapter11/views/05/components/search_box.rb
================
# frozen_string_literal: true
# Define a module here to make it possible to define a component
# class within an example file without needing to define a module first.
module SearchBox
end

================
File: Chapter11/views/05/results/index.html.erb
================
<div class="w-full p-4">
  <%= render SearchBox::Component.new(action: search_results_path, placeholder: "Search results by quiz title or student name") %>
  <%= @results.find_each do |result| %>
    <%- @course = result.quiz.course -%>
    <%- prev_result = result.quiz.results.where(user: result.user, attempt: ...result.attempt).order(attempt: :desc).first -%>
    <%= render partial: "quizzes/student_result", locals: {result:, quiz: result.quiz, prev_result:} %>
  <% end %>
</div>

================
File: Chapter11/views/06/components/search_box/component.html.erb
================
<%= form_with(url:, class: "relative mb-4 flex w-full shadow-sm flex-wrap items-stretch") do |f| %>
  <div class="absolute z-[2] inset-y-4 left-0 flex items-center pl-3 pointer-events-none w-5 h-5">
    <i class="fa fa-search text-gray-400"></i>
  </div>
  <%= f.search_field :q, placeholder:, class: "min-w-0 flex-auto relative block rounded border border-gray-200 outline-none px-3 py-3 focus:border-blue-300 placeholder-gray-400 pl-10" %>
  <% if button? %>
    <%= f.submit "Search", class: "absolute right-2.5 bottom-2.5 rounded p-1.5 px-2 text-sm bg-blue-600 text-white inline-block font-medium cursor-pointer hover:bg-blue-500 active:bg-blue-700" %>
  <% end %>
<% end %>

================
File: Chapter11/views/06/components/search_box/component.rb
================
# frozen_string_literal: true
# We only need to initialize it here to get the correct source location,
# used to lookup templates
class SearchBox::Component < ApplicationViewComponent
end

================
File: Chapter11/views/06/components/search_box/component.yml
================
en:
  placeholder: "Search"

================
File: Chapter11/views/06/components/search_box.rb
================
# frozen_string_literal: true
# Define a module here to make it possible to define a component
# class within an example file without needing to define a module first.
module SearchBox
end

================
File: Chapter11/views/07/components/flash/banner/component.html.erb
================
<div class="max-w-sm bg-white border-t-4 rounded-b px-4 py-3 shadow-md <%= level_class %>">
  <p class="text-sm"><%= content %></p>
</div>

================
File: Chapter11/views/07/components/flash/banner/component.rb
================
# frozen_string_literal: true
class Flash::Banner::Component < ApplicationViewComponent
  param :text
  option :level, default: proc { :info }
  def render? = text.presence?
  def level_class
    case level
    when :info then "bg-blue-100 text-blue-800"
    when :error then "bg-red-100 text-red-800"
    end
  end
end

================
File: Chapter11/views/07/components/flash/component.html.erb
================
<div class="flex justify-center">
  <%= render Banner.new(alert, level: :error) %>
  <%= render Banner.new(notice, level: :info) %>
</div>

================
File: Chapter11/views/07/components/flash/component.rb
================
# frozen_string_literal: true
# We only need to initialize it here to get the correct source location,
# used to lookup templates
class SearchBox::Component < ApplicationViewComponent
  option :alert
  option :notice
end

================
File: Chapter11/views/07/components/pure_flash/_component.html.erb
================
<div class="flex justify-center">
  <%- if c.alert -%>
    <div class="max-w-sm bg-white border-t-4 border-red-500 rounded-b text-red-900 px-4 py-3 shadow-md">
      <p class="text-sm"><%= c.alert %></p>
    </div>
  <%- end -%>
  <%- if c.notice -%>
    <div class="max-w-sm bg-white border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md">
      <p class="text-sm"><%= c.notice %></p>
    </div>
  <%- end -%>
</div>

================
File: Chapter11/views/07/components/pure_flash/component.rb
================
# frozen_string_literal: true
class PureFlash::Component
  attr_reader :alert, :notice
  def initialize(alert: nil, notice: nil)
    @alert = alert
    @notice = notice
  end
  def render_in(view_context)
    view_context.render(partial: "components/pure_flash/component", locals: {c: self})
  end
  def format = :html
end

================
File: Chapter11/views/07/components/_flash.html.erb
================
<div class="flex justify-center">
  <%- if alert -%>
    <div class="max-w-sm bg-white border-t-4 border-red-500 rounded-b text-red-900 px-4 py-3 shadow-md">
      <p class="text-sm"><%= alert %></p>
    </div>
  <%- end -%>
  <%- if notice -%>
    <div class="max-w-sm bg-white border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md">
      <p class="text-sm"><%= notice %></p>
    </div>
  <%- end -%>
</div>

================
File: Chapter11/views/courses/_side_info.html.erb
================
<aside class="flex flex-col justify-start align-baseline flex-grow-0 border-r mr-3 pr-3">
  <label class="text-sm text-gray-500 mb-1">Course</label>
  <%= link_to @course.title, @course, class: "text-sm font-medium mb-2 cursor-pointer text-blue-600 hover:underline" %>
  <label class="text-sm text-gray-500 mb-1">Category</label>
  <span class="text-sm font-medium mb-2"><%= @course.category %></span>
  <label class="text-sm text-gray-500 mb-1">#&nbsp;students</label>
  <span class="text-sm font-medium mb-2"><%= @course.students_count %></span>
</aside>

================
File: Chapter11/views/quizzes/_student_result.html.erb
================
<div class="block rounded-lg bg-white p-6 shadow w-[400px] mb-2">
  <header class="flex flex-row justify-between">
    <h3
      class="mb-2 text-xl font-medium leading-tight text-neutral-800">
      <%= quiz.title %>
    </h3>
    <span class="<%= result.passed? ? "text-green-500" : "text-red-500"%>">
      <%= result.passed? ? "passed" : "failed" %>
    </span>
  </header>
  <p>
    <i class="fa fa-user"></i>
    <%= link_to result.user.name, result.user, class: "text-blue-600 cursor-pointer hover:underline" %>
  </p>
  <div class="flex flex-row items-baseline mr-2">
    <label class="text-sm text-gray-500 mr-1">Score</label>
    <span><%= result.score %> / <%= quiz.score %> (<%= l(result.created_at, format: :short) %>)</span>
  </div>
  <%- if result.attempt > 1 -%>
    <div class="flex flex-row items-baseline mr-2">
      <label class="text-sm text-gray-500 mr-1">Previous Attempt</label>
      <span><%= prev_result.score %> / <%= quiz.score %>
      (<%= l(prev_result.created_at, format: :short) %>)</span>
    </div>
  <%- end -%>
</div>

================
File: Chapter11/views/results/index.html.erb
================
<div class="w-full p-4">
  <%= form_with(url: search_results_path, class: "relative mb-4 flex w-full shadow-sm flex-wrap items-stretch") do |f| %>
    <%= f.text_field :q, placeholder: "Search results by quiz title or student name", class: "min-w-0 flex-auto relative block rounded-l border border-gray-200 outline-none px-3 py-2 focus:border-blue-300" %>
    <%= f.submit "Search", class: "rounded-r py-3 px-5 bg-blue-600 text-white inline-block font-medium cursor-pointer hover:bg-blue-500 active:bg-blue-700" %>
  <% end %>
  <%= @results.find_each do |result| %>
    <%- @course = result.quiz.course -%>
    <%- prev_result = result.quiz.results.where(user: result.user, attempt: ...result.attempt).order(attempt: :desc).first -%>
    <%= render partial: "quizzes/student_result", locals: {result:, quiz: result.quiz, prev_result:} %>
  <% end %>
</div>

================
File: Chapter11/00-partial-locals.rb
================
require_relative "./prelude"
using ChapterHelpers
# Make it possible to use `render` anywhere
using(Module.new do # :ignore:
  refine Object do
    def render(*, **) = ApplicationController.render(*, layout: nil, **)
  end
end)
# Populate data
user = User.create!(name: "Vova Dem")
alice = User.create!(name: "Alice")
course = Course.create!(title: "Layered Rails", category: "Web Dev")
quiz = course.quizzes.create(title: "Active Record basics", max_attempts: 1, score: 6)
quiz_vc = course.quizzes.create(title: "View components", max_attempts: 2, score: 9)
course.students << user
course.students << alice
result = quiz.results.create!(user: alice, score: 5, passed: true, created_at: 4.days.ago)
result2 = quiz_vc.results.create!(user:, score: 2, passed: false, created_at: 233.hours.ago)
result3 = quiz_vc.results.create!(user:, attempt: 2, score: 7, passed: true, created_at: 453.minutes.ago)
begin
  render partial: "quizzes/student_result", locals: {}
rescue => err
  puts err.message
end
puts render partial: "quizzes/student_result", locals: {quiz:, result:}
begin
  render partial: "quizzes/student_result", locals: {quiz: quiz_vc, result: result3}
rescue => err
  puts err.message
end
puts render partial: "quizzes/student_result", locals: {quiz: quiz_vc, result: result3, prev_result: result2}

================
File: Chapter11/01-partial-instance-variables.rb
================
require_relative "./prelude"
using ChapterHelpers
# Make it possible to use `render` anywhere
using(Module.new do # :ignore:
  refine Object do
    def render(*, **) = ApplicationController.render(*, layout: nil, **)
  end
end)
# Populate data
user = User.create!(name: "Vova Dem")
course = Course.create!(title: "Layered Rails", category: "Web Dev")
quiz = course.quizzes.create(title: "Active Record basics", max_attempts: 1, score: 6)
course.students << user
result = quiz.results.create!(user:, score: 5, passed: true, created_at: 4.days.ago)
begin
  render partial: "quizzes/student_result", locals: {quiz:, result:}
rescue => err
  puts err.message
end

================
File: Chapter11/02-partial-strict-locals.rb
================
require_relative "./prelude"
using ChapterHelpers
# Make it possible to use `render` anywhere
using(Module.new do # :ignore:
  refine Object do
    def render(*, **) = ApplicationController.render(*, layout: nil, **)
  end
end)
# Populate data
user = User.create!(name: "Vova Dem")
course = Course.create!(title: "Layered Rails", category: "Web Dev")
quiz = course.quizzes.create(title: "Active Record basics", max_attempts: 1, score: 6)
course.students << user
result = quiz.results.create!(user:, score: 5, passed: true, created_at: 4.days.ago)
begin
  render partial: "quizzes/student_result", locals: {}
rescue => err
  puts err.message
end
begin
  render partial: "quizzes/student_result", locals: {quiz:, result:, foo: "bar"}
rescue => err
  puts err.message
end

================
File: Chapter11/03-search-box-partial.rb
================
require_relative "./prelude"
using ChapterHelpers
# This example file is meant to be used with a Rails server to see the updated search box UI.
# Run the server and choose the 03-xxx example:
#  CHAPTER=11 bin/rails s
# Populate data
user = User.create!(name: "Vova Dem")
alice = User.create!(name: "Alice")
course = Course.create!(title: "Layered Rails", category: "Web Dev")
quiz = course.quizzes.create(title: "Active Record basics", max_attempts: 1, score: 6)
quiz_vc = course.quizzes.create(title: "View components", max_attempts: 2, score: 9)
course.students << user
course.students << alice
result = quiz.results.create!(user: alice, score: 5, passed: true, created_at: 4.days.ago)
result2 = quiz_vc.results.create!(user:, score: 2, passed: false, created_at: 233.hours.ago)
result3 = quiz_vc.results.create!(user:, attempt: 2, score: 7, passed: true, created_at: 453.minutes.ago)
results = Result.all
binding.render <<~ERB
  <%- @results = results -%>
  <%= render template: "results/index" %>
ERB

================
File: Chapter11/04-search-box-helper.rb
================
require_relative "./prelude"
using ChapterHelpers
# Populate data
user = User.create!(name: "Vova Dem")
alice = User.create!(name: "Alice")
course = Course.create!(title: "Layered Rails", category: "Web Dev")
quiz = course.quizzes.create(title: "Active Record basics", max_attempts: 1, score: 6)
quiz_vc = course.quizzes.create(title: "View components", max_attempts: 2, score: 9)
course.students << user
course.students << alice
result = quiz.results.create!(user: alice, score: 5, passed: true, created_at: 4.days.ago)
result2 = quiz_vc.results.create!(user:, score: 2, passed: false, created_at: 233.hours.ago)
result3 = quiz_vc.results.create!(user:, attempt: 2, score: 7, passed: true, created_at: 453.minutes.ago)
module UIHelper
  def search_box(url:, placeholder: "Search", variant: :full)
    form_with(url:, class: "relative mb-4 flex w-full shadow-sm flex-wrap items-stretch") do |f|
      concat(content_tag(:div, "", class: "absolute z-[2] inset-y-4 left-0 flex items-center pl-3 pointer-events-none w-5 h-5") do
        content_tag(:i, "", class: "fa fa-search text-gray-400")
      end)
      concat f.text_field :q, placeholder:, class: "min-w-0 flex-auto relative block rounded border border-gray-200 outline-none px-3 py-3 focus:border-blue-300 placeholder-gray-400 pl-10"
      if variant == :full
        concat f.submit "Search", class: "absolute right-2.5 bottom-2.5 rounded p-1.5 px-2 text-sm bg-blue-600 text-white inline-block font-medium cursor-pointer hover:bg-blue-500 active:bg-blue-700"
      end
    end
  end
end
# Register heleprs manually (Rails loads them from app/helpers) # :ignore:
ApplicationController.helper UIHelper
binding.render <<~ERB
  <%= search_box(url: search_results_path, placeholder: "Search results", variant: :compact) %>
ERB
binding.render <<~ERB
  <%= search_box(url: search_results_path, placeholder: "Search results", variant: :full) %>
ERB

================
File: Chapter11/05-plain-view-components.rb
================
require_relative "./prelude"
using ChapterHelpers
# Make it possible to use `render` anywhere
using(Module.new do # :ignore:
  refine Object do
    def render(*, **) = ApplicationController.render(*, layout: nil, **)
  end
end)
# Populate data
user = User.create!(name: "Vova Dem")
alice = User.create!(name: "Alice")
course = Course.create!(title: "Layered Rails", category: "Web Dev")
quiz = course.quizzes.create(title: "Active Record basics", max_attempts: 1, score: 6)
quiz_vc = course.quizzes.create(title: "View components", max_attempts: 2, score: 9)
course.students << user
course.students << alice
result = quiz.results.create!(user: alice, score: 5, passed: true, created_at: 4.days.ago)
result2 = quiz_vc.results.create!(user:, score: 2, passed: false, created_at: 233.hours.ago)
result3 = quiz_vc.results.create!(user:, attempt: 2, score: 7, passed: true, created_at: 453.minutes.ago)
class SearchBox::Component
  attr_reader :action, :placeholder
  def initialize(
    action:, placeholder: "Search", variant: :full
  )
    @action = action
    @placeholder = placeholder
    @variant = variant
  end
  def button? = @variant == :full
  def render_in(view_context)
    view_context.render(partial: "components/search_box/component", locals: {c: self})
  end
  def format = :html
end
render SearchBox::Component.new(action: "#")
render SearchBox::Component.new(action: "#", variant: :short)
class SearchBox::Component
  def render_in(view_context)
    view_context.render(inline: template, locals: {search_box: self})
  end
  def template
    <<~'ERB'
      <%= form_with(url: search_box.action, class: "relative mb-4 flex w-full shadow-sm flex-wrap items-stretch") do |f| %>
        <div class="absolute z-[2] inset-y-4 left-0 flex items-center pl-3 pointer-events-none w-5 h-5">
          <i class="fa fa-search text-gray-400"></i>
        </div>
        <%= f.search_field :q, placeholder: search_box.placeholder, required: true, class: "min-w-0 flex-auto relative block rounded border border-gray-200 outline-none px-3 py-3 focus:border-blue-300 placeholder-gray-400 pl-10" %>
        <% if search_box.button? %>
          <%= f.submit "Search", class: "absolute right-2.5 bottom-2.5 rounded p-1.5 px-2 text-sm bg-blue-600 text-white inline-block font-medium cursor-pointer hover:bg-blue-500 active:bg-blue-700" %>
        <% end %>
      <% end %>
    ERB
  end
end
render SearchBox::Component.new(action: "#")
render SearchBox::Component.new(action: "#", variant: :short)

================
File: Chapter11/06-view-component.rb
================
require_relative "./prelude"
using ChapterHelpers
# Make it possible to use `render` anywhere
using(Module.new do # :ignore:
  refine Object do
    def render(*, **) = ApplicationController.render(*, layout: nil, **)
  end
end)
# Populate data
user = User.create!(name: "Vova Dem")
alice = User.create!(name: "Alice")
course = Course.create!(title: "Layered Rails", category: "Web Dev")
quiz = course.quizzes.create(title: "Active Record basics", max_attempts: 1, score: 6)
quiz_vc = course.quizzes.create(title: "View components", max_attempts: 2, score: 9)
course.students << user
course.students << alice
result = quiz.results.create!(user: alice, score: 5, passed: true, created_at: 4.days.ago)
result2 = quiz_vc.results.create!(user:, score: 2, passed: false, created_at: 233.hours.ago)
result3 = quiz_vc.results.create!(user:, attempt: 2, score: 7, passed: true, created_at: 453.minutes.ago)
class ApplicationViewComponent < ViewComponent::Base
end
class SearchBox::Component < ApplicationViewComponent
  attr_reader :url, :placeholder
  def initialize(
    url:, placeholder: "Search", variant: :full
  )
    @url = url
    @placeholder = placeholder
    @variant = variant
  end
  private def button? = @variant == :full
end
render SearchBox::Component.new(url: "#")
class ApplicationViewComponent < ViewComponent::Base
  extend Dry::Initializer[undefined: false]
end
class SearchBox::Component < ApplicationViewComponent
  option :url
  option :placeholder, optional: true
  option :variant, default: proc { :full }
  def before_render
    raise ArgumentError, "Unknown variant: #{variant}" unless %i[full compact].include?(variant)
    @placeholder ||= t(".placeholder")
  end
  private def button? = variant == :full
end
render SearchBox::Component.new(url: "#", variant: :compact)
begin
  render SearchBox::Component.new(url: "#", variant: :another)
rescue => err
  puts err.message
end
require "rails/test_help"
require "view_component/test_helpers"
class SearchBox::ComponentTest < ViewComponent::TestCase
  def test_render_default_full
    render_inline(
      SearchBox::Component.new(
        url: "#", placeholder: "Search things"
      )
    )
    assert_selector "input[type='submit']"
    assert_selector "input[type='search'][placeholder='Search things']"
  end
  def test_render_compact
    render_inline(SearchBox::Component.new(url: "#", variant: :compact))
    assert_no_selector "input[type='submit']"
  end
end
Minitest.run

================
File: Chapter11/prelude.rb
================
require_relative "../lib/helpers"
using ChapterHelpers
gems do
  gem "view_component", "~> 3.0"
  gem "view_component-contrib", "~> 0.2.2"
  gem "dry-initializer", "3.1.1"
  gem "capybara", "~> 3.39"
  gem "benchmark-ips", "2.10.0"
  gem "benchmark-memory", "0.2.0"
end
schema do
  create_table :users, force: true do |t|
    t.string :name, null: true
    t.timestamps
  end
  create_table :courses, force: true do |t|
    t.string :title, null: false
    t.string :category, null: false
    t.integer :students_count, null: false, default: 0
    t.timestamps
  end
  create_table :assignments, force: true do |t|
    t.belongs_to :course, null: false
    t.belongs_to :user, null: false
    t.timestamps
  end
  create_table :quizzes, force: true do |t|
    t.belongs_to :course, null: false
    t.string :title, null: false
    t.integer :score, null: false, default: 0
    t.integer :max_attempts, null: false, default: 1
    t.timestamps
  end
  create_table :results, force: true do |t|
    t.belongs_to :quiz, null: false
    t.belongs_to :user, null: false
    t.integer :score, null: false, default: 0
    t.integer :attempt, null: false, default: 1
    t.boolean :passed, null: false, default: false
    t.timestamps
  end
end
routes do
  resources :results, only: [:index] do
    post :search, on: :collection, as: :search
  end
  resources :users, only: [:show]
  resources :courses, only: [:show]
end
require_relative "../lib/boot"
class User < ApplicationRecord
  has_many :assignments, dependent: :destroy, inverse_of: :user
  has_many :courses, through: :assignments
end
class Course < ApplicationRecord
  has_many :quizzes, dependent: :destroy, inverse_of: :course
  has_many :assignments, dependent: :destroy, inverse_of: :course
  has_many :students, through: :assignments, source: :user
end
class Assignment < ApplicationRecord
  belongs_to :user
  belongs_to :course, counter_cache: :students_count
end
class Quiz < ApplicationRecord
  belongs_to :course
  has_many :results, dependent: :destroy, inverse_of: :quiz
end
class Result < ApplicationRecord
  belongs_to :quiz
  belongs_to :user
end
# Only used to preview partials in the browser
class ResultsController < ApplicationController
  def index
    @results = Result.all
  end
  def search
    @results =
      if params[:q].present?
        Result.joins(:user, :quiz).where("users.name LIKE ?", "%#{params[:q]}%").or(
          Result.joins(:user, :quiz).where("quizzes.title LIKE ?", "%#{params[:q]}%")
        )
      else
        Result.all
      end
    render action: :index
  end
end
class UsersController < ApplicationController
  def show = render plain: "Not implemented"
end
class CoursesController < ApplicationController
  def show = render plain: "Not implemented"
end

================
File: Chapter12/config/00/layerize.yml
================
default: &default
   model: "CakeGPT-1.0"
development:
  <<: *default
test:
  <<: *default
  api_key: secret_cake
  callback_url: "http://localhost:3000/callbacks/test"
production:
  <<: *default
  # we use a newer, more expensive, and slower model in production
  model: "CakeGPT-2.0"
  callback_url: "https://callbacks.myapp.io/cakes"

================
File: Chapter12/config/layerize.yml
================
default: &default
   model: "CakeGPT-1.0"
   api_key: <%= Rails.application.credentials.layerize&.api_key %>
development:
  <<: *default
  callback_url: <%= ENV.fetch("LAYERIZE_CALLBACK_URL") { Rails.application.credentials.layerize&.callback_url } %>
test:
  <<: *default
  api_key: secret_cake
  callback_url: "http://localhost:3000/callbacks/test"
production:
  <<: *default
  # we use a newer, more expensive, and slower model in production
  model: "CakeGPT-2.0"
  callback_url: "https://callbacks.myapp.io/cakes"

================
File: Chapter12/lib/rubocop/lint_rails_env.rb
================
module RuboCop
  module Cop
    module Lint
      class RailsEnv < RuboCop::Cop::Cop
        MSG = "Avoid Rails.env in application code, " \
              "use configuration parameters instead"
        def_node_matcher :rails_env?, <<~PATTERN
          (send {(const nil? :Rails) (const (cbase) :Rails)} :env)
        PATTERN
        def on_send(node)
          return unless rails_env?(node)
          add_offense(
            (node.parent.type == :send) ? node.parent : node,
            location: :selector, message: MSG
          )
        end
      end
    end
  end
end

================
File: Chapter12/.rubocop.yml
================
inherit_from: "../.rubocop.yml"
require:
  - ./lib/rubocop/lint_rails_env
Lint/RailsEnv:
  Enabled: true
  Exclude:
    - 'config/**/*.rb'

================
File: Chapter12/00-multi-source-configuration.rb
================
require_relative "./prelude"
using ChapterHelpers
class LayerizeClient
  def initialize
    @api_key = credentials&.api_key || yml_config[:api_key]
    @model = yml_config[:model]
    @callback_url = ENV["LAYERIZE_CALLBACK_URL"] ||
      credentials&.callback_url ||
      yml_config[:callback_url]
  end
  private
  def credentials = Rails.application.credentials.layerize
  def yml_config =
    @yml_config ||= Rails.application.config_for(:layerize)
end
# Extend with pretty printing capabilities
class LayerizeClient # :ignore:
  def inspect = "<#{self.class} api_key=#{@api_key} model=#{@model} callback=#{@callback_url}>"
end
puts LayerizeClient.new.inspect

================
File: Chapter12/01-multi-source-yaml.rb
================
require_relative "./prelude"
using ChapterHelpers
class LayerizeClient
  def initialize
    @api_key = config[:api_key]
    @model = config[:model]
    @callback_url = config[:callback_url]
  end
  private
  def config =
    @config ||= Rails.application.config_for(:layerize)
end
# Extend with pretty printing capabilities
class LayerizeClient # :ignore:
  def inspect = "<#{self.class} api_key=#{@api_key} model=#{@model} callback=#{@callback_url}>"
end
puts LayerizeClient.new.inspect

================
File: Chapter12/02-rails-application-config.rb
================
require_relative "./prelude"
using ChapterHelpers
Rails.application.config.layerize = Rails.application.config_for(:layerize)
class LayerizeClient
  def initialize
    @api_key = config[:api_key]
    @model = config[:model]
    @callback_url = config[:callback_url]
  end
  private
  def config = Rails.application.config.layerize
end
# Extend with pretty printing capabilities
class LayerizeClient # :ignore:
  def inspect = "<#{self.class} api_key=#{@api_key} model=#{@model} callback=#{@callback_url}>"
end
puts LayerizeClient.new.inspect

================
File: Chapter12/03-rubocop-lint-rails-env.rb
================
require_relative "./prelude"
using ChapterHelpers
root = File.expand_path("..", __dir__) # :ignore:
example_path = File.join(__dir__, "example.rb")
begin
  # Create a temporary file with the example code
  # and delete it after the run, so RuboCop doesn't complain
  File.write(example_path, <<~RUBY)
    client = LayerizeClient.new
    client.test_mode = Rails.env.local?
  RUBY
  system "#{root}/bin/rubocop --only Lint/RailsEnv #{example_path}"
ensure
  File.delete(example_path)
end

================
File: Chapter12/04-anyway-config-basic.rb
================
require_relative "./prelude"
using ChapterHelpers
class ApplicationConfig < Anyway::Config
  class << self
    delegate_missing_to :instance
    def instance
      @instance ||= new
    end
  end
end
class LayerizeConfig < ApplicationConfig
  attr_config :api_key, :callback_url,
    model: "CakeGPT 1.0", enabled: true
  required :api_key
end
config = LayerizeConfig.new
pp config
begin
  LayerizeConfig.new(api_key: nil)
rescue => e
  puts "#{e.class}: #{e.message}"
end
p LayerizeConfig.api_key
class LayerizeClient
  def initialize(config: LayerizeConfig)
    @api_key = config.api_key
    @model = config.model
    @callback_url = config.callback_url
  end
end
# Extend with pretty printing capabilities
class LayerizeClient # :ignore:
  def inspect = "<#{self.class} api_key=#{@api_key} model=#{@model} callback=#{@callback_url}>"
end
puts LayerizeClient.new.inspect
config = LayerizeConfig.new(api_key: "another-key")
puts LayerizeClient.new(config:).inspect

================
File: Chapter12/05-anyway-config-advanced.rb
================
require_relative "./prelude"
using ChapterHelpers
class ApplicationConfig < Anyway::Config
  class << self
    delegate_missing_to :instance
    def instance
      @instance ||= new
    end
  end
end
class LayerizeConfig < ApplicationConfig
  attr_config :api_key, :callback_url,
    model: "CakeGPT 1.0", enabled: true
  required :api_key
end
class LayerizeConfig < ApplicationConfig
  attr_config :api_key, :callback_url, :enabled,
    model: "CakeGPT 1.0"
  required :api_key
  coerce_types enabled: :boolean
  on_load :validate_model
  def model_version = model.match(/(\d+\.\d+)/)[1]
  private
  def validate_model
    return if model&.match?(/^CakeGPT \d+\.\d+$/)
    raise ArgumentError, "Unknown model: #{model}"
  end
end
LayerizeConfig.new(model: "CakeGPT 1.5").model_version
begin
  LayerizeConfig.new(model: "CandyLLM 1.0")
rescue => e
  puts "#{e.class}: #{e.message}"
end
ENV["LAYERIZE_ENABLED"] = "0"
LayerizeConfig.new.enabled?

================
File: Chapter12/prelude.rb
================
require_relative "../lib/helpers"
using ChapterHelpers
gems do
  gem "anyway_config", "~> 2.5.4"
end
schema do
end
routes do
end
require_relative "../lib/boot"

================
File: Chapter13/00-puts-logging.rb
================
require_relative "./prelude"
using ChapterHelpers
class GitStarsFetcher
  URL_TEMPLATE = "https://api.github.com/repos/%s/%s"
  def stars_for(org, repo)
    puts "Fetching stars for: #{org}/#{repo}"
    uri = URI(URL_TEMPLATE % [org, repo])
    response = Net::HTTP.get_response(uri)
    if response.code != "200"
      puts "Failed to fetch stars: HTTP #{response.code}"
      return
    end
    stars = JSON.parse(response.body).fetch("stargazers_count")
    puts "Stars fetched successfully: #{stars}"
    stars
  rescue SocketError, Net::HTTPError, JSON::ParserError, KeyError => error
    puts "Failed to fetch stars: #{error.message}"
  end
end
GitStarsFetcher.new.stars_for("rails", "rails")
GitStarsFetcher.new.stars_for("rails", "rails-x")

================
File: Chapter13/01-rails-logger.rb
================
require_relative "./prelude"
using ChapterHelpers
class GitStarsFetcher
  URL_TEMPLATE = "https://api.github.com/repos/%s/%s"
  def stars_for(org, repo)
    Rails.logger.debug "Fetching stars for: #{org}/#{repo}"
    uri = URI(URL_TEMPLATE % [org, repo])
    response = Net::HTTP.get_response(uri)
    if response.code != "200"
      Rails.logger.error "Failed to fetch stars: HTTP #{response.code}"
      return
    end
    stars = JSON.parse(response.body).fetch("stargazers_count")
    Rails.logger.debug "Stars fetched successfully: #{stars}"
    stars
  rescue SocketError, Net::HTTPError, JSON::ParserError, KeyError => error
    Rails.logger.error "Failed to fetch stars: #{error.message}"
  end
end
GitStarsFetcher.new.stars_for("anycable", "anycable")
GitStarsFetcher.new.stars_for("anycable", "anycable-mqtt")

================
File: Chapter13/02-tagged-logger.rb
================
require_relative "./prelude"
using ChapterHelpers
get "/", headers: {"X-Request-ID" => "req-1", "X-User-ID" => "42"}
class GitStarsFetcher
  URL_TEMPLATE = "https://api.github.com/repos/%s/%s"
  private attr_reader :logger
  def initialize
    @logger = Rails.logger.tagged("â­ï¸")
  end
  def stars_for(org, repo)
    logger.debug "Fetching stars for: #{org}/#{repo}"
    uri = URI(URL_TEMPLATE % [org, repo])
    response = Net::HTTP.get_response(uri)
    if response.code != "200"
      logger.error "Failed to fetch stars: HTTP #{response.code}"
      return
    end
    stars = JSON.parse(response.body).fetch("stargazers_count")
    logger.debug "Stars fetched successfully: #{stars}"
    stars
  rescue SocketError, Net::HTTPError, JSON::ParserError, KeyError => error
    logger.error "Failed to fetch stars: #{error.message}"
  end
end
GitStarsFetcher.new.stars_for("test-prof", "test-prof")

================
File: Chapter13/03-rails-error.rb
================
require_relative "./prelude"
using ChapterHelpers
# Test error reporting subscriber
class ErrorSubscriber
  def self.report(error, handled:, severity:, context:, **_other)
    $stdout.puts "[ERROR REPORTED] #{error.class}: #{error.message}\n" \
      "  Context: #{context.inspect}\n" \
      "  Callsite: #{error.backtrace.take(1).first}"
  end
end
Rails.application.executor.error_reporter.subscribe(ErrorSubscriber)
class GitStarsFetcher
  URL_TEMPLATE = "https://api.github.com/repos/%s/%s"
  private attr_reader :logger
  def initialize
    @logger = Rails.logger
  end
  def stars_for(org, repo)
    logger.debug "Fetching stars for: #{org}/#{repo}"
    uri = URI(URL_TEMPLATE % [org, repo])
    response = Net::HTTP.get_response(uri)
    if response.code != "200"
      logger.error "Failed to fetch stars: HTTP #{response.code}"
      return
    end
    stars = JSON.parse(response.body).fetch("stargazers_count")
    logger.debug "Stars fetched successfully: #{stars}"
    stars
  rescue SocketError, Net::HTTPError, JSON::ParserError, KeyError => error
    Rails.error.report(error, handled: true)
    logger.error "Failed to fetch stars: #{error.message}"
  end
end
Rails.error.set_context(user_id: "2023")
GitStarsFetcher.new.stars_for("rspec", "rspec-core")

================
File: Chapter13/04-instrumentation.rb
================
require_relative "./prelude"
using ChapterHelpers
# Warm-up schema cache
User.first
ActiveSupport::Notifications.subscribe("sql.active_record") do |event|
  puts "SQL: #{event.payload[:sql]}"
end
User.first
# Adding instrumentation to GitStarsFetcher
class GitStarsFetcher
  URL_TEMPLATE = "https://api.github.com/repos/%s/%s"
  def stars_for(org, repo)
    uri = URI(URL_TEMPLATE % [org, repo])
    payload = {repo: "#{org}/#{repo}"}
    ActiveSupport::Notifications.instrument("fetch_stars.gh", payload) do
      response = Net::HTTP.get_response(uri)
      stars = JSON.parse(response.body).fetch("stargazers_count")
      payload[:stars] = stars
    end
  rescue SocketError, Net::HTTPError, JSON::ParserError, KeyError => error
    Rails.error.report(error, handled: true)
  end
end
subscriber = ActiveSupport::Notifications.subscribe("fetch_stars.gh") do
  puts("repo=#{_1.payload[:repo]} stars=#{_1.payload[:stars]} duration=#{_1.duration}")
end
GitStarsFetcher.new.stars_for("rails", "rails")
ActiveSupport::Notifications.unsubscribe(subscriber) # :ignore:
# Creating a log subscriber
class GHLogSubscriber < ActiveSupport::LogSubscriber
  def fetch_stars(event)
    repo = event.payload[:repo]
    ex = event.payload[:exception_object]
    if ex
      error do
        "Failed to fetch stars for #{repo}: #{ex.message}"
      end
    else
      debug do
        "Fetched stars for #{repo}: #{event.payload[:stars]} (#{event.duration.round(2)}ms)"
      end
    end
  end
end
GHLogSubscriber.attach_to :gh
GitStarsFetcher.new.stars_for("rails", "rails")
# Configuring metrics with Yabeda
Yabeda.configure do
  counter :gh_stars_call_total
  counter :gh_stars_call_failed_total
  histogram :gh_stars_call_duration, unit: :millisecond, buckets: [10, 50, 100, 200, 500]
end
# Define a custom Yabeda collector for testing purposes
require "yabeda/base_adapter"
module Yabeda
  module Stdout
    class Adapter < BaseAdapter
      def register_counter!(_metric)
      end
      def perform_counter_increment!(counter, tags, increment)
        $stdout.puts "[METRICS] #{counter.name}#{build_tags(tags)} #{increment}"
      end
      def register_gauge!(_metric)
      end
      def perform_gauge_set!(metric, tags, value)
        $stdout.puts "[METRICS] #{metric.name}#{build_tags(tags)} #{value}"
      end
      def register_histogram!(_metric)
      end
      def perform_histogram_measure!(metric, tags, value)
        $stdout.puts "[METRICS] #{metric.name}#{build_tags(tags)} #{value}"
      end
      private
      def build_tags(tags)
        return if tags.nil? || tags.empty?
        tags.map { |k, v| "#{k}=#{v}" }.join(",").then { "{#{_1}}" }
      end
      Yabeda.register_adapter(:stdout, new)
    end
  end
end
# Adding Yabeda subscriber
ActiveSupport::Notifications.subscribe("fetch_stars.gh") do
  Yabeda.gh_stars_call_total.increment({})
  if _1.payload[:exception]
    Yabeda.gh_stars_call_failed_total.increment({})
  else
    Yabeda.gh_stars_call_duration.measure({}, _1.duration)
  end
end
GitStarsFetcher.new.stars_for("rails", "rails")

================
File: Chapter13/05-active-storage-custom-proxy.rb
================
# We don't need logs for this example # :ignore:
$logging = false
# Define routes before loading prelude
require_relative "../lib/helpers"
using ChapterHelpers
routes do # :ignore:output
  direct :imgproxy_active_storage do |model, options|
    expires_in = options.delete(:expires_in) { ActiveStorage.urls_expire_in }
    # Serve originals via the built-in Rails proxy
    if model.respond_to?(:signed_id)
      route_for(
        :rails_service_blob_proxy,
        model.signed_id(expires_in:),
        model.filename,
        options
      )
    else
      options = {expires: expires_in, filename: model.filename}
      # options.merge!(Imgproxy.variation_to_params(model.variation))
      model.blob.imgproxy_url(**options)
    end
  end
end
require_relative "./prelude"
# Add avatar to users
class User < ApplicationRecord
  has_one_attached :avatar
end
image = File.open(File.join(__dir__, "assets/me.png"))
user = User.create!(name: "Vova")
user.avatar.attach(io: image, filename: "me.png")
puts url_for user.avatar
puts url_for user.avatar.variant(resize: "200x150")
# Now let's add imgproxy integration
Imgproxy.configure do |config|
  config.endpoint = "https://imgproxy.example.com"
  config.key = "secret"
  config.salt = "pepper"
  config.base64_encode_urls = true
end
Imgproxy.extend_active_storage! # :ignore:output
ActiveStorage.resolve_model_to_route = :imgproxy_active_storage
puts url_for user.avatar
puts url_for user.avatar.variant(resize: "200x150")

================
File: Chapter13/prelude.rb
================
require_relative "../lib/helpers"
using ChapterHelpers
gems do
  gem "imgproxy", "2.1.0"
  gem "yabeda", "0.11.0"
end
schema do
  create_table :users, force: true do |t|
    t.string :name, null: true
    t.timestamps
  end
end
routes do
end
configure do
  next if $logging == false
  # Setup a production-like logger
  logger = ActiveSupport::Logger.new($stdout)
  logger.formatter = Logger::Formatter.new
  logger.level = :debug
  config.logger = ActiveSupport::TaggedLogging.new(logger)
  config.log_tags = [
    :request_id,
    proc { |request| request.headers["X-USER-ID"] }
  ]
end
require "net/http"
require "json"
require_relative "../lib/boot"
class User < ApplicationRecord
end

================
File: gemfiles/rubocop.gemfile
================
source "https://rubygems.org"

gem "standard", "~> 1.0"

================
File: gemfiles/rubocop.gemfile.lock
================
GEM
  remote: https://rubygems.org/
  specs:
    ast (2.4.2)
    json (2.6.2)
    parallel (1.22.1)
    parser (3.1.3.0)
      ast (~> 2.4.1)
    rainbow (3.1.1)
    regexp_parser (2.6.1)
    rexml (3.2.5)
    rubocop (1.39.0)
      json (~> 2.3)
      parallel (~> 1.10)
      parser (>= 3.1.2.1)
      rainbow (>= 2.2.2, < 4.0)
      regexp_parser (>= 1.8, < 3.0)
      rexml (>= 3.2.5, < 4.0)
      rubocop-ast (>= 1.23.0, < 2.0)
      ruby-progressbar (~> 1.7)
      unicode-display_width (>= 1.4.0, < 3.0)
    rubocop-ast (1.24.0)
      parser (>= 3.1.1.0)
    rubocop-performance (1.15.1)
      rubocop (>= 1.7.0, < 2.0)
      rubocop-ast (>= 0.4.0)
    ruby-progressbar (1.11.0)
    standard (1.18.1)
      rubocop (= 1.39.0)
      rubocop-performance (= 1.15.1)
    unicode-display_width (2.3.0)

PLATFORMS
  aarch64-linux
  arm64-darwin-21
  arm64-darwin-22
  ruby
  x86_64-darwin-20
  x86_64-darwin-21
  x86_64-linux

DEPENDENCIES
  standard (~> 1.0)

BUNDLED WITH
   2.3.23

================
File: lib/app/views/layouts/application.html.erb
================
<!DOCTYPE html>
<html>
  <head>
    <title>Layering Rails Examples</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="shortcut icon" href="/favicon.ico">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
  </head>

  <body>
    <main class="container min-h-screen mx-auto pt-28 pb-28 px-5 flex h-screen">
      <div class="absolute mt-1 w-full top-2 left-0">
        <div class="flex justify-center">
          <%- if flash[:alert] -%>
            <div class="max-w-sm bg-white border-t-4 border-red-500 rounded-b text-red-900 px-4 py-3 shadow-md">
              <p class="text-sm"><%= flash[:alert] %></p>
            </div>
          <%- end -%>
          <%- if flash[:notice] -%>
            <div class="max-w-sm bg-white border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md">
              <p class="text-sm"><%= flash[:notice] %></p>
            </div>
          <%- end -%>
        </div>
      </div>
      <%= yield %>
    </main>
  </body>
</html>

================
File: lib/app/views/welcome/index.html.erb
================
<div class="min-w-full">
  <h1 class="font-bold text-4xl mb-5">
    <% if current_chapter %>
      Layering Rails: Chapter <%= current_chapter.id %>
    <% else %>
      Layering Rails
    <% end %>
  </h1>

  <% if current_chapter %>
    <% unless current_chapter.active_example %>
      <p class="text-xl grey-text">Code examples you can play around with!</p>

      <hr class="mt-5">

      <ul>
        <% current_chapter.examples.each do |example| %>
          <li class="flex flex-row items-baseline">
            <span><%= example.id %>.</span>
            <%= button_to example, example_path(example), method: :post, class: "cursor-pointer text-red-500 hover:text-black background-transparent px-1 py-1 outline-none focus:outline-none mr-1 mb-1" %>
          </li>
        <% end %>
      </ul>
    <% else %>
      <div class="flex flex-row items-baseline">
        <h2 class="font-bold text-xl">
          Loaded example: <%= current_chapter.active_example.name %>
        </h2>
        <%= button_to "Reset", examples_reset_path, method: :delete, class: "cursor-pointer text-red-500 hover:text-black background-transparent px-1 py-1 outline-none focus:outline-none ml-2"%>
      </div>
      <h4 class="text-gray">Source: <%= current_chapter.active_example.path %></h4>
      <hr class="mt-5">
      <div class="mt-5">
        <h2 class="font-bold text-xl mb-1">Availalble endpoints:</h2>
        <% endpoints = current_chapter.router.recognizable_paths %>
        <% if endpoints.any? %>
          <ul class="list-disc">
            <% endpoints.each do |route| %>
              <li>
                <% if route.match?(/\/:\w+/) %>
                  <code><%= route %></code>
                <% else %>
                  <%= link_to route, class: "text-red-500 hover:text-black" do %>
                    <code><%= route %></code>
                  <% end %>
                <% end %>
              </li>
            <% end %>
          </ul>
        <% else %>
          <span>No enpoints</span>
        <% end %>
      </div>
    <% end %>
  <% end %>
</div>

================
File: lib/config/credentials.yml.enc
================
ExZ3fAVpYe5aZ02h9ZBqWTsnPGmRHVxQZCat2apc0N2sZyc7mDBTtGIvYal19fpE3wEv5bSht3WbO6Fr9GvU1h4ZbHysYEZ29tbm1su28eWeWk2sBFnz3W+vxy/schg=--1vy6LZu+kFbR4PG4--PY41lRwMh5G2hHDSocS0YQ==

================
File: lib/config/puma.rb
================
# Use clustered mode to make it possible to reload the app without restarting a server
workers 1

================
File: lib/app.rb
================
# frozen_string_literal: true
# Define base classes for the app.
# Must be declared after application initialization to work correctly
# (for example, URL helpers in controllers are not included properly if defined before initialization)
class ApplicationRecord < ActiveRecord::Base
  self.abstract_class = true
end
module ApplicationHelper
end
class Current < ActiveSupport::CurrentAttributes
  attribute :user
end
class ApplicationController < ActionController::Base
  helper_method :current_user
  layout -> { request.headers["X-EXAMPLE"].present? ? false : "application" }
  before_action :configure_example_view_path
  def current_user
    return @current_user if instance_variable_defined?(:@current_user)
    @current_user = Current.user || User.find_by(id: cookies[:user_id])
  end
  private
  def current_chapter
    return @current_chapter if @current_chapter
    chapter = ENV.fetch("CHAPTER") do
      request.headers["X-CHAPTER"]
    end&.rjust(2, "0")
    @current_chapter = chapter ? Chapter.new(chapter) : nil
    return unless @current_chapter
    example = request.headers["X-EXAMPLE"].presence
    @current_chapter.find_example(example)&.then(&:active!) if example
    @current_chapter
  end
  def configure_example_view_path
    return unless current_chapter&.active_example
    prepend_view_path File.join(current_chapter.root, "views", current_chapter.active_example.id)
  end
end
class ApplicationJob < ActiveJob::Base
end
class ApplicationMailer < ActionMailer::Base
  layout nil
  after_action :prevent_delivery
  private
  # Do not attempt deliveries, just print a message
  def prevent_delivery
    message.perform_deliveries = false
    reply_to = message.reply_to ? "reply_to=#{message.reply_to.join(",")} " : ""
    puts "[EMAIL SENT] to=#{message.to&.join(",")} #{reply_to}subject=#{message.subject} body=#{message.body}"
  end
end
class Chapter
  class Example
    attr_reader :path, :name, :id
    def initialize(path)
      @path = path
      filename = File.basename(path)
      filename.match(/^(?<id>\d+)-(?<name>.+)\.rb$/) => {id:, name:}
      @id = id
      @name = name.tr("-", "_").titleize
    end
    def loaded?
      return @active if instance_variable_defined?(:@active)
      @active = $LOADED_FEATURES.include?(path)
    end
    def active! = @active = true
    def to_s = name
    def to_param = id
    def load
      Kernel.require(path)
    end
  end
  class Router
    attr_reader :routes
    def initialize(routes = Rails.application.routes)
      @routes = routes
    end
    def paths
      @paths ||= routes.set.routes.filter_map do
        path = _1.path.spec.to_s
        next if path.starts_with?("/rails")
        next if path.starts_with?("/_/")
        next if path == "/"
        path.sub(%r{\(.:format\)}, "")
      end.tap(&:uniq!).tap(&:sort!)
    end
    def recognizable_paths
      paths.select do
        routes.recognize_path(_1)
    rescue
      false
      end
    end
  end
  attr_reader :root, :id
  def initialize(num)
    @id = num.to_i
    @root = File.expand_path(File.join(__dir__, "../Chapter#{num}"))
  end
  def router = Router.new
  def examples
    @examples ||= Dir.glob(File.join(root, "*.rb")).filter_map do |path|
      next unless path.match?(/\/\d{2}-/)
      Example.new(path)
    end
  end
  def find_example(id)
    examples.find { _1.id == id }
  end
  def active_example
    return @active_example if instance_variable_defined?(:@active_example)
    @active_example = examples.find(&:loaded?)
  end
end
class WelcomeController < ApplicationController
  helper_method :current_chapter
  def index
  end
  def load_example
    example = current_chapter&.find_example(params[:id])
    example&.load
    redirect_to root_path
  end
  def reset_examples
    server = Puma::Server.current
    ActiveRecord::Tasks::DatabaseTasks.truncate_all
    Thread.new {
      sleep 1
      server.begin_restart
    }
    redirect_to root_path
  end
end
module ApplicationCable
  class Connection < ActionCable::Connection::Base
    identified_by :user
    def connect
      self.user = User.find_by(id: request.params[:user_id])
      reject_unauthorized_connection unless user
    end
  end
  class Channel < ActionCable::Channel::Base
  end
end

================
File: lib/application.rb
================
# frozen_string_literal: true
# This is a single file Rails application used as a skeleton for practice excercises
# Load all Rails components
require "rails/all"
require_relative "./helpers"
# config/database.yml
database = File.expand_path(File.join(__dir__, "..", "rails-book.sqlite3"))
ENV["DATABASE_URL"] = "sqlite3:#{database}"
ActiveRecord::Base.establish_connection(adapter: "sqlite3", database: database)
ActiveRecord::Base.logger = ActiveSupport::Logger.new((ENV["LOG"] == "1") ? $stdout : IO::NULL)
# db/schema.rb
ActiveRecord::Schema.define do
  self.verbose = false
  ChapterHelpers.extend!(:schema, self)
end
require "active_job/queue_adapters/inline_adapter"
# Custom Active Job adapter to perform jobs synchronously,
# but within a new thread (so, it's a combination of async and inline).
# That better ressembles the production queueing adapters by executing jobs
# within non-main threads.
module ActiveJob
  module QueueAdapters
    class AsyncInlineAdapter < InlineAdapter
      def enqueue(job)
        Thread.new { Base.execute(job.serialize) }.join
      end
    end
  end
end
# Custom Action Cable adapter which prints broadcast to standard output
module ActionCable
  module SubscriptionAdapter
    class TestPrint < Test
      def broadcast(channel, payload)
        puts "[CABLE BROADCAST] channel=#{channel} data=#{payload.inspect}"
        super
      end
    end
  end
end
# Prevent Rails from trying to require the subscription adapter file
$LOADED_FEATURES << "action_cable/subscription_adapter/test_print"
# config/application.rb
class App < Rails::Application
  config.root = __dir__
  config.eager_load = false
  config.load_defaults 7.1
  config.action_controller.allow_forgery_protection = false
  config.consider_all_requests_local = true
  config.action_dispatch.show_exceptions = :none
  config.secret_key_base = "i_am_a_secret"
  config.active_storage.service_configurations = {"local" => {"service" => "Disk", "root" => "./storage"}}
  config.active_storage.service = :local
  config.active_job.queue_adapter = :async_inline
  config.action_mailer.show_previews = false
  # Keep all credentials in a single file, since editing per-chapter credentials
  # doesn't work for a yet-unknown reason
  config.credentials.content_path = Pathname.new(File.join(__dir__, "config", "credentials.yml.enc"))
  config.credentials.key_path = Pathname.new(File.join(__dir__, "config", "master.key"))
  config.hosts = []
  config.logger = ActiveSupport::Logger.new((ENV["LOG"] == "1") ? $stdout : IO::NULL)
  # Add current chapter views
  call_locs = caller_locations(1, 10)
  prelude_path = call_locs.find { _1.path.include?("prelude.rb") }&.path
  if prelude_path
    config.paths["app/views"] << File.join(File.dirname(prelude_path), "views")
    config.paths["config"].unshift File.join(File.dirname(prelude_path), "config")
    example_path = call_locs.find { _1.path.match(/Chapter\d+\/(\d{2})-.+\.rb/) }&.path
    if example_path
      config.paths["app/views"].unshift File.join(File.dirname(prelude_path), "views", Regexp.last_match[1])
      example_config_path = File.join(File.dirname(prelude_path), "config", Regexp.last_match[1])
      config.paths["config"].unshift example_config_path if File.directory?(example_config_path)
    end
    # For view components
    config.autoload_paths << File.join(File.dirname(prelude_path), "views", "components")
    if example_path
      config.autoload_paths << File.join(File.dirname(prelude_path), "views", Regexp.last_match[1], "components")
    end
  end
  routes.default_url_options = {host: "localhost:3000"}
  routes.append do
    root to: "welcome#index"
    post "/_/chapters/:id" => "welcome#load_example", :as => :example
    delete "/_/chapters" => "welcome#reset_examples", :as => :examples_reset
    ChapterHelpers.extend!(:routes, self)
  end
  ChapterHelpers.extend!(:config, self)
  config.after_initialize do
    require_relative "./app"
  end
end
# Configure Action Cable
ActionCable.server.config.cable = {
  "adapter" => "test_print"
}
# Create Active Storage tables (unless already exists)
begin
  ActiveRecord::Base.connection.execute "select 1 from active_storage_blobs"
rescue ActiveRecord::StatementInvalid
  active_storage_migrate_dir = File.join(
    Gem.loaded_specs["activestorage"].full_gem_path,
    "db", "migrate"
  )
  Dir.children(active_storage_migrate_dir).each do
    require File.join(active_storage_migrate_dir, _1)
  end
  CreateActiveStorageTables.new.migrate(:up)
end

================
File: lib/boot.rb
================
# frozen_string_literal: true
require_relative "./environment"
Rails.application.initialize!

================
File: lib/config.ru
================
# This file is used by Rack-based servers to start the application.

require PROJECT_PATH
run Rails.application

================
File: lib/environment.rb
================
# frozen_string_literal: true
require_relative "./helpers"
# First, we setup the dependencies.
# We use inline Gemfile for that and make it possible to extend it from examples
# by using the GemsInline helper module
require "bundler/inline"
retried = false
freeze_defaults = true
begin
  gemfile(retried, quiet: true) do
    source "https://rubygems.org"
    gem "rails", "7.1.1"
    # Use Puma as a web server (so we can reload the app without reloading the server)
    gem "puma", "~> 6.0.1"
    # Rails is not fully compatible with Rack 3 yet
    gem "rack", "< 3"
    # We use in-memory sqlite as our database
    gem "sqlite3", "1.6.0"
    # Debugger could be used to dig deeper into some code examples
    gem "debug", "1.7.0"
    # Highlight code in the terminal
    gem "rouge", "4.2.0"
    if freeze_defaults
      # Freeze default gem versions to avoid Bundler conflicts
      require "timeout"
      gem "timeout", Timeout::VERSION
      require "stringio"
      gem "stringio", StringIO::VERSION
      require "psych"
      gem "psych", Psych::VERSION
      require "net/protocol"
      gem "net-protocol", Net::Protocol::VERSION
    end
    ChapterHelpers.extend!(:gemfile, self)
  end
rescue Gem::MissingSpecError
  raise if retried
  retried = true
  retry
rescue Bundler::SolveFailure
  # This may happen when defaults gems are outdated, let's try without them
  raise if !freeze_defaults
  warn "Re-trying installing without defaults gems to update them. The next run will use updated versions."
  freeze_defaults = false
  retry
end
# Then, load the Rails application
require_relative "./application"

================
File: lib/helpers.rb
================
# frozen_string_literal: true
# Rouge is only installed during the first run,
# so we should ignore the failure
begin
  require "rouge"
rescue LoadError
end
require "tempfile"
require "ripper"
module ChapterHelpers
  TRUNCATE_WIDTH = 100
  using(Module.new do
    refine String do
      def truncate(len = TRUNCATE_WIDTH)
        return self if size <= len
        self[0..(len - 5)] + "..." + self[-1..(size)]
      end
      def red = "\e[31m#{self}\e[0m"
    end
  end)
  class << self
    def extensions = @extensions ||= Hash.new { |h, k| h[k] = [] }
    def extend!(type, obj) = extensions[type].each { obj.instance_eval(&_1) }
    def const_watchers = @const_watchers ||= Hash.new { |h, k| h[k] = [] }
    def setup_const_watcher
      name_method = Module.instance_method(:name)
      TracePoint.trace(:end) do |event|
        # Ignore singletons
        next if event.self.singleton_class?
        mod_name = name_method.bind_call(event.self)
        const_watchers[mod_name].each do |block|
          block.call(event.self)
        end
      end.enable
    end
  end
  class RackResponseDecorator < SimpleDelegator
    def inspect = __getobj__.status.inspect
    # Make it posssible to access flash from response
    def flash
      headers["rails.flash"]
    end
  end
  refine Kernel do
    def gems(&block)
      ChapterHelpers.extensions[:gemfile] << block
    end
    def on_const_load(const_name, &block)
      ChapterHelpers.setup_const_watcher if ChapterHelpers.const_watchers.empty?
      ChapterHelpers.const_watchers[const_name] << block
    end
    def schema(&block)
      ChapterHelpers.extensions[:schema] << block
    end
    def routes(&block)
      ChapterHelpers.extensions[:routes] << block
    end
    def configure(&block)
      ChapterHelpers.extensions[:config] << block
    end
    def request(path, params: {}, method: :get, cookies: {}, env: {}, headers: {})
      request_env = Rack::MockRequest.env_for(
        "http://localhost:3000#{path}",
        params:,
        method:
      )
      env["HTTP_COOKIE"] = cookies.map { |k, v| "#{k}=#{v}" }.join(";") unless cookies.empty?
      env["HTTP_X_CHAPTER"], env["HTTP_X_EXAMPLE"] = caller_locations(1, 3).find do |cl|
        cl.path.match(/\bChapter(\d+)\/(\d+)-/)
      end.then { Regexp.last_match&.captures }
      headers&.each { request_env["HTTP_#{_1.upcase.tr("-", "_")}"] = _2 }
      request_env.merge!(env) unless env.empty?
      response = Rails.application.call(request_env)
      # Make flash accesible on the response object
      response[1]["rails.flash"] = ActionDispatch::Request.new(request_env.merge({"HTTP_COOKIE" => response[1]["Set-Cookie"]})).flash.to_h
      RackResponseDecorator.new(ActionDispatch::Response.new(*response))
    end
    def get(path, **options)
      request(path, **options)
    end
    def patch(path, **options)
      request(path, method: :patch, **options)
    end
    def post(path, **options)
      request(path, method: :post, **options)
    end
    def delete(path, **options)
      request(path, method: :delete, **options)
    end
    def url_for(...) = Rails.application.routes.url_helpers.url_for(...)
    # Prints the code and executes it,
    # paragraph by paragraph
    def annotate(code, path)
      bind = TOPLEVEL_BINDING.eval("binding")
      if defined?(::Rouge)
        formatter = Rouge::Formatters::Terminal256.new
        lexer = Rouge::Lexers::Ruby.new
      end
      paragraphs = code.split(/^\s*$/)
      line_num = 1
      original_stdout = $stdout.dup
      file = nil
      buffer = []
      paragraphs.each.with_index do |paragraph, i|
        file&.close
        file&.unlink
        buffer << paragraph
        paragraph = buffer.join("\n")
        # Make sure that paragraph is valid Ruby code.
        # If syntax is invalid, then this is partial code,
        # add to buffer and continue
        next unless Ripper.sexp_raw(paragraph)
        # Syntax is valid, flush buffer
        buffer.clear
        debugging = paragraph.match(/\bdebugger\b/)
        if debugging
          $stdout = original_stdout
        else
          file = Tempfile.new("#{path}_#{i}")
          $stdout.reopen(file, "w")
          $stdout.sync = true
        end
        exception = nil
        result =
          begin
            bind.eval paragraph, path, line_num
          rescue => err
            exception = err
            nil
          end
        if paragraph.include?('require_relative "./prelude"')
          raise exception if exception
          next
        end
        ignore = paragraph.match(/# :ignore:(output)?/)
        ignore_output = ignore
        if ignore && ignore[1]
          ignore_output = true
          ignore = nil
        end
        ignore_output ||= paragraph.match?(/^(class|module|def\s|require "|RSpec\.describe)/)
        paragraph.sub!(/# :ignore:(output)?/, "")
        source = paragraph.chomp
        unless result.nil? || ignore_output
          result = result.to_ary if result.respond_to?(:to_ary)
          source += " #=> #{result.inspect.truncate}"
        end
        unless ignore
          formatted =
            if formatter
              formatter.format(lexer.lex(source))
            else
              source
            end
          original_stdout.puts(formatted)
        end
        sleep 0.2
        unless ignore_output
          file.rewind
          output = file.read.strip
          unless output.empty?
            output = output.lines
            original_stdout.puts("\nâ†³ #{output.first}#{output[1..].map { "  " + _1 }.join}")
          end
          sleep 0.2
        end
        if exception
          original_stdout.puts("\n ðŸ’¥ #{exception.class.name}: #{exception.message}".red)
        end
        line_num += paragraph.lines.size
      end
      # Let SyntaxError bubble
      bind.eval(buffer.join, path) unless buffer.empty?
    ensure
      $stdout = original_stdout
    end
  end
  refine Object do
    def remove_const(name)
      Object.send(:remove_const, name)
    end
  end
  refine Binding do
    # Add #render to binding to render ERB templates within the context
    # of the current scope
    def render(erb_str)
      locals = local_variables.each.with_object({}) do |lvar, acc|
        acc[lvar] = local_variable_get(lvar)
        acc
      end
      puts ApplicationController.render(
        locals:,
        inline: erb_str
      )
    end
  end
end

================
File: .gitignore
================
log/
tmp/
storage/
*.sqlite3*

================
File: .rubocop.yml
================
require:
  - standard/cop/block_single_line_braces
inherit_gem:
  standard: config/base.yml
AllCops:
  DisplayCopNames: true
  SuggestExtensions: false
  TargetRubyVersion: 3.2
Standard/BlockSingleLineBraces:
  Enabled: false
# We often re-define classes within examples
Lint/DuplicateMethods:
  Enabled: false
# Useless assignments become useful in examples
Lint/UselessAssignment:
  Enabled: false
# I like alias
Style/Alias:
  Enabled: false
# We might need $edge_rails
Style/GlobalVars:
  Enabled: false

================
File: LICENSE
================
MIT License

Copyright (c) 2022 Packt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: Rakefile
================
# frozen_string_literal: true

require_relative "lib/application"

Rails.application.load_tasks

================
File: README.md
================
# Layered Design for Ruby on Rails Applications	
Layered Design for Ruby on Rails Applications, published by Packt

<a href="https://www.packtpub.com/product/layered-design-for-ruby-on-rails-applications/9781801813785"><img src="https://static.packt-cdn.com/products/9781801813785/cover/smaller" alt="Layered Design for Ruby on Rails Applications" height="256px" align="right"></a>

This is the code repository for [Layered Design for Ruby on Rails Applications](https://www.packtpub.com/product/layered-design-for-ruby-on-rails-applications/9781801813785), published by Packt.

**Discover practical design patterns for maintainable web applications.**

## What is this book about?
Ruby on Rails is an open-source framework for building web applications from scratch and develop a full-featured product. This book helps you keep the code maintainable while working on a Rails application by demonstrating the useful design patterns and exploring the common code abstractions.

This book covers the following exciting features:

* Discover Rails' core components and its request/response cycle
* Understand Rails' convention-over-configuration principle and its impact on development
* Explore patterns for flexibility, extensibility, and testability in Rails
* Identify and address Railsâ€™ anti-patterns for cleaner code
* Implement design patterns for handling bloated models and messy views
* Expand from mailers to multi-channel notification deliveries
* Explore different authorization models and layers
* Use a class-based approach to configuration in Rails

If you feel this book is for you, get your [copy](https://www.amazon.com/Layered-Design-Ruby-Rails-Applications/dp/1801813787) today!

<a href="https://www.packtpub.com/?utm_source=github&utm_medium=banner&utm_campaign=GitHubBanner"><img src="https://raw.githubusercontent.com/PacktPublishing/GitHub/master/GitHub.png" 
alt="https://www.packtpub.com/" border="5" /></a>


## Instructions and navigations

All of the code is organized into folders. For example, Chapter02.

The `lib/` folder contains utilities to run code snippets. Most chapter folders also contain the `prelude.rb` file
with the environment configuration for the examples (dependecies, Rails application configuration, database schema extensions, etc).

You can run any example using the `ruby` command, for example:

```sh
$ ruby Chapter01/01-request-gc-stats.rb

Total allocations: 18573
```

### Using examples runner

You can also run examples using a specific runner scripts, which prints the source code along with intermediate
return values in addition to executing the code:

```sh
ruby run.rb Chapter01/01-request-gc-stats.rb
```

Here is an example output of the runner:

<img src="./assets/demo.gif" alt="Runner demo" width="720px">

### Running Rails tasks

You can run Rails (Rake) tasks using the `bin/rails` executable:

```sh
$ bin/rails middleware

use ActionDispatch::HostAuthorization
use Rack::Sendfile
...
use Rack::TempfileReaper
run App.routes
```

You can also load the application modification for a particular chapter by specifying the `CHAPTER` env var:

```sh
$ CHAPTER=2 bin/rails routes

...
         books GET    /books(.:format)
    books#index
    categories GET    /categories(:format)
    categories#index
      category GET    /categories:id(.:format)
    categories#show
```

Finally, you can run a Rails server for a particular chapter (some chapters contain controllers and views examples). For example, for Chapter 7:

```sh
$ CHAPTER=7 bin/rails rails s

[2023-01-30 22:45:37] INFO  WEBrick 1.8.1
[2023-01-30 22:45:37] INFO  ruby 3.2.0 (2022-12-25) [aarch64-linux]
[2023-01-30 22:45:37] INFO  WEBrick::HTTPServer#start: pid=1266 port=3000
...
```

Now you can open a web server at [localhost:3000/users](http://localhost:3000/users) and play with the auto-generated Rails CRUD interface for users.

### Software and Hardware List

| Chapter  |        Software required             |           OS required               |
| -------- | ------------------------------------ | ----------------------------------- |
| 1-15     | Ruby 3.2                             |     Any OS that runs Ruby           |

### Related products <Other books you may enjoy>
* Web Development with Julia and Genie  [[Packt]](https://www.packtpub.com/product/web-development-with-julia-and-genie/9781801811132) [[Amazon]](https://www.amazon.in/Development-Julia-Genie-hands-high-performance/dp/180181113X)

* Practical Module development for Prestashop 8  [[Packt]](https://www.packtpub.com/product/practical-module-development-for-prestashop-8/9781837635962) [[Amazon]](https://www.amazon.in/Practical-Module-Development-Prestashop-customizable/dp/183763596X/ref=tmm_pap_swatch_0?_encoding=UTF8&qid=&sr=)

## Get to Know the Author
**Vladimir Dementyev** is a principal backend engineer at Evil Martians, a product development consultancy from Earth, focusing on building maintainable web applications and developersâ€™ productivity. He is the creator of popular open source tools, such as AnyCable and TestProf, and a contributor to many other open source projects, including Ruby on Rails and Ruby itself. Vladimir plays an active role in the Ruby community through his code contributions and by speaking at conferences and sharing his passion for coding via articles and blog posts. For his contributions to the Ruby ecosystem, Vladimir was awarded the Fukuoka Ruby Award in 2021 and the Ruby Hero Russia Award in 2017.

================
File: run.rb
================
require_relative "./lib/helpers"
using ChapterHelpers
ARGV.each do |filename|
  contents = File.read(filename)
  eval <<~CODE # rubocop:disable Security/Eval, Style/EvalWithLocation
    annotate(
      %q(#{contents}),
      filename
    )
  CODE
end





================================================================
End of Codebase
================================================================
